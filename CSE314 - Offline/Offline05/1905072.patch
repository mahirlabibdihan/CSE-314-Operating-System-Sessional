diff --git a/Makefile b/Makefile
index 39a99d7..c66e335 100644
--- a/Makefile
+++ b/Makefile
@@ -132,6 +132,8 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_thread\
+	$U/_producer_consumer\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
@@ -153,7 +155,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 3
+CPUS := 8
 endif
 
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..de424f3 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -10,180 +10,195 @@ struct stat;
 struct superblock;
 
 // bio.c
-void            binit(void);
-struct buf*     bread(uint, uint);
-void            brelse(struct buf*);
-void            bwrite(struct buf*);
-void            bpin(struct buf*);
-void            bunpin(struct buf*);
+void binit(void);
+struct buf *bread(uint, uint);
+void brelse(struct buf *);
+void bwrite(struct buf *);
+void bpin(struct buf *);
+void bunpin(struct buf *);
 
 // console.c
-void            consoleinit(void);
-void            consoleintr(int);
-void            consputc(int);
+void consoleinit(void);
+void consoleintr(int);
+void consputc(int);
 
 // exec.c
-int             exec(char*, char**);
+int exec(char *, char **);
 
 // file.c
-struct file*    filealloc(void);
-void            fileclose(struct file*);
-struct file*    filedup(struct file*);
-void            fileinit(void);
-int             fileread(struct file*, uint64, int n);
-int             filestat(struct file*, uint64 addr);
-int             filewrite(struct file*, uint64, int n);
+struct file *filealloc(void);
+void fileclose(struct file *);
+struct file *filedup(struct file *);
+void fileinit(void);
+int fileread(struct file *, uint64, int n);
+int filestat(struct file *, uint64 addr);
+int filewrite(struct file *, uint64, int n);
 
 // fs.c
-void            fsinit(int);
-int             dirlink(struct inode*, char*, uint);
-struct inode*   dirlookup(struct inode*, char*, uint*);
-struct inode*   ialloc(uint, short);
-struct inode*   idup(struct inode*);
-void            iinit();
-void            ilock(struct inode*);
-void            iput(struct inode*);
-void            iunlock(struct inode*);
-void            iunlockput(struct inode*);
-void            iupdate(struct inode*);
-int             namecmp(const char*, const char*);
-struct inode*   namei(char*);
-struct inode*   nameiparent(char*, char*);
-int             readi(struct inode*, int, uint64, uint, uint);
-void            stati(struct inode*, struct stat*);
-int             writei(struct inode*, int, uint64, uint, uint);
-void            itrunc(struct inode*);
+void fsinit(int);
+int dirlink(struct inode *, char *, uint);
+struct inode *dirlookup(struct inode *, char *, uint *);
+struct inode *ialloc(uint, short);
+struct inode *idup(struct inode *);
+void iinit();
+void ilock(struct inode *);
+void iput(struct inode *);
+void iunlock(struct inode *);
+void iunlockput(struct inode *);
+void iupdate(struct inode *);
+int namecmp(const char *, const char *);
+struct inode *namei(char *);
+struct inode *nameiparent(char *, char *);
+int readi(struct inode *, int, uint64, uint, uint);
+void stati(struct inode *, struct stat *);
+int writei(struct inode *, int, uint64, uint, uint);
+void itrunc(struct inode *);
 
 // ramdisk.c
-void            ramdiskinit(void);
-void            ramdiskintr(void);
-void            ramdiskrw(struct buf*);
+void ramdiskinit(void);
+void ramdiskintr(void);
+void ramdiskrw(struct buf *);
 
 // kalloc.c
-void*           kalloc(void);
-void            kfree(void *);
-void            kinit(void);
+void *kalloc(void);
+void kfree(void *);
+void kinit(void);
 
 // log.c
-void            initlog(int, struct superblock*);
-void            log_write(struct buf*);
-void            begin_op(void);
-void            end_op(void);
+void initlog(int, struct superblock *);
+void log_write(struct buf *);
+void begin_op(void);
+void end_op(void);
 
 // pipe.c
-int             pipealloc(struct file**, struct file**);
-void            pipeclose(struct pipe*, int);
-int             piperead(struct pipe*, uint64, int);
-int             pipewrite(struct pipe*, uint64, int);
+int pipealloc(struct file **, struct file **);
+void pipeclose(struct pipe *, int);
+int piperead(struct pipe *, uint64, int);
+int pipewrite(struct pipe *, uint64, int);
 
 // printf.c
-void            printf(char*, ...);
-void            panic(char*) __attribute__((noreturn));
-void            printfinit(void);
+void printf(char *, ...);
+void panic(char *) __attribute__((noreturn));
+void printfinit(void);
 
 // proc.c
-int             cpuid(void);
-void            exit(int);
-int             fork(void);
-int             growproc(int);
-void            proc_mapstacks(pagetable_t);
-pagetable_t     proc_pagetable(struct proc *);
-void            proc_freepagetable(pagetable_t, uint64);
-int             kill(int);
-int             killed(struct proc*);
-void            setkilled(struct proc*);
-struct cpu*     mycpu(void);
-struct cpu*     getmycpu(void);
-struct proc*    myproc();
-void            procinit(void);
-void            scheduler(void) __attribute__((noreturn));
-void            sched(void);
-void            sleep(void*, struct spinlock*);
-void            userinit(void);
-int             wait(uint64);
-void            wakeup(void*);
-void            yield(void);
-int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
-int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
-void            procdump(void);
+int cpuid(void);
+void exit(int);
+int fork(void);
+int growproc(int);
+void proc_mapstacks(pagetable_t);
+pagetable_t proc_pagetable(struct proc *);
+void proc_freepagetable(pagetable_t, uint64);
+int kill(int);
+int killed(struct proc *);
+void setkilled(struct proc *);
+struct cpu *mycpu(void);
+struct cpu *getmycpu(void);
+struct proc *myproc();
+void procinit(void);
+void scheduler(void) __attribute__((noreturn));
+void sched(void);
+void sleep(void *, struct spinlock *);
+void userinit(void);
+int wait(uint64);
+void wakeup(void *);
+void yield(void);
+int either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
+int either_copyin(void *dst, int user_src, uint64 src, uint64 len);
+void procdump(void);
+
+void thread_freepagetable(pagetable_t, uint64);
+/**
+ * @author Mahir Labib Dihan
+ */
+int thread_create(uint64 fcn, uint64 arg, uint64 stack);
+int thread_join(int thread_id);
+void thread_exit(void);
+void threadinit(void);
+void thread_sleep(void *, uint8 *);
+void thread_wakeup(void *);
 
 // swtch.S
-void            swtch(struct context*, struct context*);
+void swtch(struct context *, struct context *);
 
 // spinlock.c
-void            acquire(struct spinlock*);
-int             holding(struct spinlock*);
-void            initlock(struct spinlock*, char*);
-void            release(struct spinlock*);
-void            push_off(void);
-void            pop_off(void);
+void acquire(struct spinlock *);
+int holding(struct spinlock *);
+void initlock(struct spinlock *, char *);
+void release(struct spinlock *);
+void push_off(void);
+void pop_off(void);
 
 // sleeplock.c
-void            acquiresleep(struct sleeplock*);
-void            releasesleep(struct sleeplock*);
-int             holdingsleep(struct sleeplock*);
-void            initsleeplock(struct sleeplock*, char*);
+void acquiresleep(struct sleeplock *);
+void releasesleep(struct sleeplock *);
+int holdingsleep(struct sleeplock *);
+void initsleeplock(struct sleeplock *, char *);
 
 // string.c
-int             memcmp(const void*, const void*, uint);
-void*           memmove(void*, const void*, uint);
-void*           memset(void*, int, uint);
-char*           safestrcpy(char*, const char*, int);
-int             strlen(const char*);
-int             strncmp(const char*, const char*, uint);
-char*           strncpy(char*, const char*, int);
+int memcmp(const void *, const void *, uint);
+void *memmove(void *, const void *, uint);
+void *memset(void *, int, uint);
+char *safestrcpy(char *, const char *, int);
+int strlen(const char *);
+int strncmp(const char *, const char *, uint);
+char *strncpy(char *, const char *, int);
 
 // syscall.c
-void            argint(int, int*);
-int             argstr(int, char*, int);
-void            argaddr(int, uint64 *);
-int             fetchstr(uint64, char*, int);
-int             fetchaddr(uint64, uint64*);
-void            syscall();
+void argint(int, int *);
+int argstr(int, char *, int);
+void argaddr(int, uint64 *);
+int fetchstr(uint64, char *, int);
+int fetchaddr(uint64, uint64 *);
+void syscall();
 
 // trap.c
-extern uint     ticks;
-void            trapinit(void);
-void            trapinithart(void);
+extern uint ticks;
+void trapinit(void);
+void trapinithart(void);
 extern struct spinlock tickslock;
-void            usertrapret(void);
+void usertrapret(void);
 
 // uart.c
-void            uartinit(void);
-void            uartintr(void);
-void            uartputc(int);
-void            uartputc_sync(int);
-int             uartgetc(void);
+void uartinit(void);
+void uartintr(void);
+void uartputc(int);
+void uartputc_sync(int);
+int uartgetc(void);
 
 // vm.c
-void            kvminit(void);
-void            kvminithart(void);
-void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
-int             mappages(pagetable_t, uint64, uint64, uint64, int);
-pagetable_t     uvmcreate(void);
-void            uvmfirst(pagetable_t, uchar *, uint);
-uint64          uvmalloc(pagetable_t, uint64, uint64, int);
-uint64          uvmdealloc(pagetable_t, uint64, uint64);
-int             uvmcopy(pagetable_t, pagetable_t, uint64);
-void            uvmfree(pagetable_t, uint64);
-void            uvmunmap(pagetable_t, uint64, uint64, int);
-void            uvmclear(pagetable_t, uint64);
-pte_t *         walk(pagetable_t, uint64, int);
-uint64          walkaddr(pagetable_t, uint64);
-int             copyout(pagetable_t, uint64, char *, uint64);
-int             copyin(pagetable_t, char *, uint64, uint64);
-int             copyinstr(pagetable_t, char *, uint64, uint64);
-
+void kvminit(void);
+void kvminithart(void);
+void kvmmap(pagetable_t, uint64, uint64, uint64, int);
+int mappages(pagetable_t, uint64, uint64, uint64, int);
+pagetable_t uvmcreate(void);
+void uvmfirst(pagetable_t, uchar *, uint);
+uint64 uvmalloc(pagetable_t, uint64, uint64, int);
+uint64 uvmdealloc(pagetable_t, uint64, uint64);
+int uvmcopy(pagetable_t, pagetable_t, uint64);
+void uvmfree(pagetable_t, uint64);
+void uvmunmap(pagetable_t, uint64, uint64, int);
+void uvmclear(pagetable_t, uint64);
+pte_t *walk(pagetable_t, uint64, int);
+uint64 walkaddr(pagetable_t, uint64);
+int copyout(pagetable_t, uint64, char *, uint64);
+int copyin(pagetable_t, char *, uint64, uint64);
+int copyinstr(pagetable_t, char *, uint64, uint64);
+/**
+ * @author Mahir Labib Dihan
+ */
+int uvmmirror(pagetable_t, pagetable_t, uint64, uint64);
+void uvmfreethread(pagetable_t, uint64);
 // plic.c
-void            plicinit(void);
-void            plicinithart(void);
-int             plic_claim(void);
-void            plic_complete(int);
+void plicinit(void);
+void plicinithart(void);
+int plic_claim(void);
+void plic_complete(int);
 
 // virtio_disk.c
-void            virtio_disk_init(void);
-void            virtio_disk_rw(struct buf *, int);
-void            virtio_disk_intr(void);
+void virtio_disk_init(void);
+void virtio_disk_rw(struct buf *, int);
+void virtio_disk_intr(void);
 
 // number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+#define NELEM(x) (sizeof(x) / sizeof((x)[0]))
diff --git a/kernel/main.c b/kernel/main.c
index f0d3171..3e01b1a 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -29,6 +29,7 @@ main()
     fileinit();      // file table
     virtio_disk_init(); // emulated hard disk
     userinit();      // first user process
+    threadinit();    // Offline05
     __sync_synchronize();
     started = 1;
   } else {
diff --git a/kernel/proc.c b/kernel/proc.c
index 959b778..c67e608 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -15,6 +15,11 @@ struct proc *initproc;
 int nextpid = 1;
 struct spinlock pid_lock;
 
+/// @author: Mahir Labib Dihan
+int nextmemid = 1;
+struct spinlock memlocks[NPROC];
+struct spinlock memid_lock;
+
 extern void forkret(void);
 static void freeproc(struct proc *p);
 
@@ -29,40 +34,49 @@ struct spinlock wait_lock;
 // Allocate a page for each process's kernel stack.
 // Map it high in memory, followed by an invalid
 // guard page.
-void
-proc_mapstacks(pagetable_t kpgtbl)
+void proc_mapstacks(pagetable_t kpgtbl)
 {
   struct proc *p;
-  
-  for(p = proc; p < &proc[NPROC]; p++) {
+
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
     char *pa = kalloc();
-    if(pa == 0)
+    if (pa == 0)
       panic("kalloc");
-    uint64 va = KSTACK((int) (p - proc));
+    uint64 va = KSTACK((int)(p - proc));
     kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
   }
 }
 
 // initialize the proc table.
-void
-procinit(void)
+void procinit(void)
 {
   struct proc *p;
-  
+
   initlock(&pid_lock, "nextpid");
   initlock(&wait_lock, "wait_lock");
-  for(p = proc; p < &proc[NPROC]; p++) {
-      initlock(&p->lock, "proc");
-      p->state = UNUSED;
-      p->kstack = KSTACK((int) (p - proc));
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    initlock(&p->lock, "proc");
+    p->state = UNUSED;
+    p->kstack = KSTACK((int)(p - proc));
   }
 }
 
+// initialized thread functionalities
+void threadinit(void)
+{
+  initlock(&memid_lock, "nextmemid");
+  struct spinlock *sl;
+  for (sl = memlocks; sl < &memlocks[NPROC]; sl++)
+  {
+    initlock(sl, "memlock");
+  }
+}
 // Must be called with interrupts disabled,
 // to prevent race with process being moved
 // to a different CPU.
-int
-cpuid()
+int cpuid()
 {
   int id = r_tp();
   return id;
@@ -70,7 +84,7 @@ cpuid()
 
 // Return this CPU's cpu struct.
 // Interrupts must be disabled.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
   int id = cpuid();
@@ -79,7 +93,7 @@ mycpu(void)
 }
 
 // Return the current struct proc *, or zero if none.
-struct proc*
+struct proc *
 myproc(void)
 {
   push_off();
@@ -89,11 +103,10 @@ myproc(void)
   return p;
 }
 
-int
-allocpid()
+int allocpid()
 {
   int pid;
-  
+
   acquire(&pid_lock);
   pid = nextpid;
   nextpid = nextpid + 1;
@@ -102,20 +115,37 @@ allocpid()
   return pid;
 }
 
+int allocmemid()
+{
+  int mem_id;
+
+  acquire(&memid_lock);
+  mem_id = nextmemid;
+  nextmemid = nextmemid + 1;
+  release(&memid_lock);
+
+  return mem_id;
+}
+
 // Look in the process table for an UNUSED proc.
 // If found, initialize state required to run in the kernel,
 // and return with p->lock held.
 // If there are no free procs, or a memory allocation fails, return 0.
-static struct proc*
+static struct proc *
 allocproc(void)
 {
   struct proc *p;
-
-  for(p = proc; p < &proc[NPROC]; p++) {
+  int i;
+  for (p = proc, i = 0; p < &proc[NPROC]; p++, i++)
+  {
     acquire(&p->lock);
-    if(p->state == UNUSED) {
+    if (p->state == UNUSED)
+    {
+      p->memlock = &memlocks[i]; // Dihan: One memlock for each process
       goto found;
-    } else {
+    }
+    else
+    {
       release(&p->lock);
     }
   }
@@ -126,7 +156,8 @@ found:
   p->state = USED;
 
   // Allocate a trapframe page.
-  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+  if ((p->trapframe = (struct trapframe *)kalloc()) == 0)
+  {
     freeproc(p);
     release(&p->lock);
     return 0;
@@ -134,7 +165,8 @@ found:
 
   // An empty user page table.
   p->pagetable = proc_pagetable(p);
-  if(p->pagetable == 0){
+  if (p->pagetable == 0)
+  {
     freeproc(p);
     release(&p->lock);
     return 0;
@@ -155,11 +187,18 @@ found:
 static void
 freeproc(struct proc *p)
 {
-  if(p->trapframe)
-    kfree((void*)p->trapframe);
+  if (p->trapframe)
+    kfree((void *)p->trapframe);
   p->trapframe = 0;
-  if(p->pagetable)
-    proc_freepagetable(p->pagetable, p->sz);
+
+  if (p->pagetable) // Should we free in case of thread?
+  {
+    if (p->is_thread == 0)
+      proc_freepagetable(p->pagetable, p->sz);
+    else
+      thread_freepagetable(p->pagetable, p->sz);
+  }
+
   p->pagetable = 0;
   p->sz = 0;
   p->pid = 0;
@@ -169,6 +208,13 @@ freeproc(struct proc *p)
   p->killed = 0;
   p->xstate = 0;
   p->state = UNUSED;
+
+  /**
+   * @author Mahir Labib Dihan
+   */
+  p->memlock = 0;
+  p->mem_id = 0;
+  p->is_thread = 0;
 }
 
 // Create a user page table for a given process, with no user memory,
@@ -180,23 +226,26 @@ proc_pagetable(struct proc *p)
 
   // An empty page table.
   pagetable = uvmcreate();
-  if(pagetable == 0)
+  if (pagetable == 0)
     return 0;
 
   // map the trampoline code (for system call return)
   // at the highest user virtual address.
   // only the supervisor uses it, on the way
   // to/from user space, so not PTE_U.
-  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
-              (uint64)trampoline, PTE_R | PTE_X) < 0){
+  if (mappages(pagetable, TRAMPOLINE, PGSIZE,
+               (uint64)trampoline, PTE_R | PTE_X) < 0)
+  {
     uvmfree(pagetable, 0);
     return 0;
   }
 
   // map the trapframe page just below the trampoline page, for
   // trampoline.S.
-  if(mappages(pagetable, TRAPFRAME, PGSIZE,
-              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
+  // Mapping virtual address:TRAPFRAME to physical address:p->trapframe
+  if (mappages(pagetable, TRAPFRAME, PGSIZE,
+               (uint64)(p->trapframe), PTE_R | PTE_W) < 0)
+  {
     uvmunmap(pagetable, TRAMPOLINE, 1, 0);
     uvmfree(pagetable, 0);
     return 0;
@@ -207,44 +256,49 @@ proc_pagetable(struct proc *p)
 
 // Free a process's page table, and free the
 // physical memory it refers to.
-void
-proc_freepagetable(pagetable_t pagetable, uint64 sz)
+void proc_freepagetable(pagetable_t pagetable, uint64 sz)
 {
   uvmunmap(pagetable, TRAMPOLINE, 1, 0);
   uvmunmap(pagetable, TRAPFRAME, 1, 0);
   uvmfree(pagetable, sz);
 }
 
+// Free a process's page table, and free the
+// physical memory it refers to.
+void thread_freepagetable(pagetable_t pagetable, uint64 sz)
+{
+  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+  uvmunmap(pagetable, TRAPFRAME, 1, 0);
+  uvmfreethread(pagetable, sz);
+}
 // a user program that calls exec("/init")
 // assembled from ../user/initcode.S
 // od -t xC ../user/initcode
 uchar initcode[] = {
-  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
-  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
-  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
-  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
-  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
-  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00
-};
+    0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
+    0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
+    0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
+    0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
+    0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
+    0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00};
 
 // Set up first user process.
-void
-userinit(void)
+void userinit(void)
 {
   struct proc *p;
 
   p = allocproc();
   initproc = p;
-  
+
   // allocate one user page and copy initcode's instructions
   // and data into it.
   uvmfirst(p->pagetable, initcode, sizeof(initcode));
   p->sz = PGSIZE;
 
   // prepare for the very first "return" from kernel to user.
-  p->trapframe->epc = 0;      // user program counter
-  p->trapframe->sp = PGSIZE;  // user stack pointer
+  p->trapframe->epc = 0;     // user program counter
+  p->trapframe->sp = PGSIZE; // user stack pointer
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -254,48 +308,190 @@ userinit(void)
   release(&p->lock);
 }
 
+// Allocate PTEs and physical memory to grow process from oldsz to
+// newsz, which need not be page aligned.  Returns new size or 0 on error.
+int uvmallocsync(struct proc *from, struct proc *to)
+{
+  pte_t *pte;
+  uint64 pa, va;
+  uint flags;
+  uint64 oldsz = from->sz;
+  uint64 newsz = to->sz;
+
+  oldsz = PGROUNDUP(oldsz);
+  for (va = oldsz; va < newsz; va += PGSIZE)
+  {
+    if ((pte = walk(to->pagetable, va, 0)) == 0)
+    {
+      return -1;
+    }
+    if ((*pte & PTE_V) == 0)
+    {
+      return -1;
+    }
+    pa = PTE2PA(*pte);
+    flags = PTE_FLAGS(*pte);
+
+    if (mappages(from->pagetable, va, PGSIZE, pa, flags) != 0)
+    {
+      uvmdealloc(from->pagetable, va, oldsz);
+      return -1;
+    }
+  }
+  return 0;
+}
+
 // Grow or shrink user memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
+  // Should we grow child process also?
   uint64 sz;
   struct proc *p = myproc();
-
+  // printf("PID: %d\n", p->pid);
+  // Only one thread should grow/shrink the heap at a time
+  acquire(p->memlock);
+  // why not lock all memlock with same mem_id?
   sz = p->sz;
-  if(n > 0){
-    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
+
+  if (n > 0)
+  {
+    if ((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0)
+    {
+      release(p->memlock);
       return -1;
     }
-  } else if(n < 0){
+  }
+  else if (n < 0)
+  {
     sz = uvmdealloc(p->pagetable, sz, sz + n);
   }
+
+  /**
+   * @author Mahir Labib Dihan
+   */
+  // Change size of all process with same mem_id
+  // Also their page tables should be changed
+
+  // Map the new pages to all thread pagetable?
+  // Delete the new pages from all thread pagetable?
   p->sz = sz;
+
+  struct proc *pp;
+  for (pp = proc; pp < &proc[NPROC]; pp++)
+  {
+    if (pp != p && pp->mem_id == p->mem_id)
+    {
+      // printf("%d %d\n", pp->mem_id, p->mem_id);
+      if (uvmmirror(p->pagetable, pp->pagetable, p->sz, pp->sz) < 0)
+      {
+        panic("can't synchronize");
+        return -1;
+      }
+      // printf("Synchronized");
+      pp->sz = sz;
+    }
+  }
+
+  release(p->memlock);
   return 0;
 }
+// Function: 1 -> Copied from fork()
+// Create a new thread, copying the parent.
+// Sets up child kernel stack to execute from fcn
+int thread_create(uint64 fcn, uint64 arg, uint64 stack)
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *p = myproc();
+
+  // Allocate process.
+  if ((np = allocproc()) == 0)
+  {
+    return -1;
+  }
+
+  // Push arg to user stack
+
+  // Important: each thread has its own proc, and hence its own trapframe. However, since all threads share the same process’s address space, their trapframes may be mapped to the same address and will interfere each other. You therefore need to map each thread’s trapframe to a unique address. https://courses.cs.duke.edu/fall22/compsci310/thread.html
+
+  // Copy user memory from parent to child.
+  acquire(p->memlock);
+  if (uvmmirror(p->pagetable, np->pagetable, p->sz, 0) < 0)
+  {
+    freeproc(np);
+    release(p->memlock);
+    release(&np->lock);
+    return -1;
+  }
+  release(p->memlock);
+
+  // copy saved user registers.
+  *(np->trapframe) = *(p->trapframe);
+
+  // Cause fork to return 0 in the child.
+  np->memlock = p->memlock;
+  np->mem_id = p->mem_id;
+  np->sz = p->sz;
+  np->trapframe->a0 = arg;        // We just need to pass the pointer
+  np->trapframe->ra = 0xffffffff; // fake return PC
+  np->trapframe->sp = stack + PGSIZE;
+  np->trapframe->sp -= np->trapframe->sp % 16; // riscv sp must be 16-byte aligned
+  np->is_thread = 1;
+  np->trapframe->epc = fcn; // Start from fcn
+  // increment reference counts on open file descriptors.
+  for (i = 0; i < NOFILE; i++)
+    if (p->ofile[i])
+      np->ofile[i] = filedup(p->ofile[i]);
+  np->cwd = idup(p->cwd);
+
+  safestrcpy(np->name, p->name, sizeof(p->name));
+
+  pid = np->pid;
+
+  release(&np->lock);
+
+  acquire(&wait_lock);
+  np->parent = p;
+  release(&wait_lock);
+
+  acquire(&np->lock);
+  np->state = RUNNABLE;
+  release(&np->lock);
+
+  return pid;
+}
 
 // Create a new process, copying the parent.
 // Sets up child kernel stack to return as if from fork() system call.
-int
-fork(void)
+int fork(void)
 {
   int i, pid;
   struct proc *np;
   struct proc *p = myproc();
-
+  if (p->is_thread)
+  {
+    // threads can't call fork
+    return -1;
+  }
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
+  {
     return -1;
   }
 
   // Copy user memory from parent to child.
-  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
+  if (uvmcopy(p->pagetable, np->pagetable, p->sz) < 0)
+  {
     freeproc(np);
     release(&np->lock);
     return -1;
   }
+
   np->sz = p->sz;
 
+  np->mem_id = allocmemid();
+
   // copy saved user registers.
   *(np->trapframe) = *(p->trapframe);
 
@@ -303,8 +499,8 @@ fork(void)
   np->trapframe->a0 = 0;
 
   // increment reference counts on open file descriptors.
-  for(i = 0; i < NOFILE; i++)
-    if(p->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (p->ofile[i])
       np->ofile[i] = filedup(p->ofile[i]);
   np->cwd = idup(p->cwd);
 
@@ -325,35 +521,101 @@ fork(void)
   return pid;
 }
 
+// Function: 4 -> Copied from reparent()
+// Pass p's abandoned children to p->parent.
+// Caller must hold wait_lock.
+void reparentthread(struct proc *p)
+{
+  struct proc *pp;
+
+  for (pp = proc; pp < &proc[NPROC]; pp++)
+  {
+    if (pp->parent == p)
+    {
+      pp->parent = p->parent;
+      wakeup(p->parent);
+    }
+  }
+}
+
 // Pass p's abandoned children to init.
 // Caller must hold wait_lock.
-void
-reparent(struct proc *p)
+void reparent(struct proc *p)
 {
   struct proc *pp;
 
-  for(pp = proc; pp < &proc[NPROC]; pp++){
-    if(pp->parent == p){
+  for (pp = proc; pp < &proc[NPROC]; pp++)
+  {
+    if (pp->parent == p)
+    {
       pp->parent = initproc;
       wakeup(initproc);
     }
   }
 }
 
+// Function: 3 -> Copied from exit()
+// Exit the current thread.  Does not return.
+// An exited thread remains in the zombie state
+// until its parent calls thread_join().
+void thread_exit(void)
+{
+  struct proc *p = myproc();
+
+  if (p == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for (int fd = 0; fd < NOFILE; fd++)
+  {
+    if (p->ofile[fd])
+    {
+      struct file *f = p->ofile[fd];
+      fileclose(f);
+      p->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(p->cwd);
+  end_op();
+  p->cwd = 0;
+
+  acquire(&wait_lock);
+
+  // Dihan: Give any children to parent.
+  reparentthread(p);
+
+  // Parent might be sleeping in thread_join().
+  wakeup(p->parent);
+
+  acquire(&p->lock);
+
+  // p->xstate = status;
+  p->state = ZOMBIE;
+
+  release(&wait_lock);
+
+  // Jump into the scheduler, never to return.
+  sched();
+  panic("zombie exit");
+}
+
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait().
-void
-exit(int status)
+void exit(int status)
 {
   struct proc *p = myproc();
 
-  if(p == initproc)
+  if (p == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(int fd = 0; fd < NOFILE; fd++){
-    if(p->ofile[fd]){
+  for (int fd = 0; fd < NOFILE; fd++)
+  {
+    if (p->ofile[fd])
+    {
       struct file *f = p->ofile[fd];
       fileclose(f);
       p->ofile[fd] = 0;
@@ -367,12 +629,26 @@ exit(int status)
 
   acquire(&wait_lock);
 
+  /**
+   * @author Mahir Labib Dihan
+   */
+  // All child thread dies with parent process
+  struct proc *pp;
+  for (pp = proc; pp < &proc[NPROC]; pp++)
+  {
+    if (pp != p && pp->mem_id == p->mem_id && pp->is_thread)
+    {
+      acquire(&pp->lock);
+      freeproc(pp);
+      release(&pp->lock);
+    }
+  }
   // Give any children to init.
   reparent(p);
 
   // Parent might be sleeping in wait().
   wakeup(p->parent);
-  
+
   acquire(&p->lock);
 
   p->xstate = status;
@@ -385,10 +661,57 @@ exit(int status)
   panic("zombie exit");
 }
 
+// Function: 2 -> Copied from wait()
+// Wait for a child thread to exit and return its pid.
+// Return -1 if thread_id not exists
+int thread_join(int thread_id)
+{
+  struct proc *pp;
+  int havekids, pid;
+  struct proc *p = myproc();
+
+  acquire(&wait_lock);
+
+  for (;;)
+  {
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for (pp = proc; pp < &proc[NPROC]; pp++)
+    {
+      if (pp->parent == p && pp->pid == thread_id)
+      {
+        // make sure the child isn't still in exit() or swtch().
+        acquire(&pp->lock);
+
+        havekids = 1;
+        if (pp->state == ZOMBIE)
+        {
+          // Found one.
+          pid = pp->pid;
+          freeproc(pp);
+          release(&pp->lock);
+          release(&wait_lock);
+          return pid;
+        }
+        release(&pp->lock);
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if (!havekids || killed(p))
+    {
+      release(&wait_lock);
+      return -1;
+    }
+
+    // Wait for a child to exit.
+    sleep(p, &wait_lock); // DOC: wait-sleep
+  }
+}
+
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(uint64 addr)
+int wait(uint64 addr)
 {
   struct proc *pp;
   int havekids, pid;
@@ -396,20 +719,25 @@ wait(uint64 addr)
 
   acquire(&wait_lock);
 
-  for(;;){
+  for (;;)
+  {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(pp = proc; pp < &proc[NPROC]; pp++){
-      if(pp->parent == p){
+    for (pp = proc; pp < &proc[NPROC]; pp++)
+    {
+      if (pp->parent == p)
+      {
         // make sure the child isn't still in exit() or swtch().
         acquire(&pp->lock);
 
         havekids = 1;
-        if(pp->state == ZOMBIE){
+        if (pp->state == ZOMBIE)
+        {
           // Found one.
           pid = pp->pid;
-          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
-                                  sizeof(pp->xstate)) < 0) {
+          if (addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
+                                   sizeof(pp->xstate)) < 0)
+          {
             release(&pp->lock);
             release(&wait_lock);
             return -1;
@@ -424,13 +752,14 @@ wait(uint64 addr)
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || killed(p)){
+    if (!havekids || killed(p))
+    {
       release(&wait_lock);
       return -1;
     }
-    
+
     // Wait for a child to exit.
-    sleep(p, &wait_lock);  //DOC: wait-sleep
+    sleep(p, &wait_lock); // DOC: wait-sleep
   }
 }
 
@@ -441,20 +770,22 @@ wait(uint64 addr)
 //  - swtch to start running that process.
 //  - eventually that process transfers control
 //    via swtch back to the scheduler.
-void
-scheduler(void)
+void scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
-  
+
   c->proc = 0;
-  for(;;){
+  for (;;)
+  {
     // Avoid deadlock by ensuring that devices can interrupt.
     intr_on();
 
-    for(p = proc; p < &proc[NPROC]; p++) {
+    for (p = proc; p < &proc[NPROC]; p++)
+    {
       acquire(&p->lock);
-      if(p->state == RUNNABLE) {
+      if (p->state == RUNNABLE)
+      {
         // Switch to chosen process.  It is the process's job
         // to release its lock and then reacquire it
         // before jumping back to us.
@@ -478,19 +809,18 @@ scheduler(void)
 // be proc->intena and proc->noff, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&p->lock))
+  if (!holding(&p->lock))
     panic("sched p->lock");
-  if(mycpu()->noff != 1)
+  if (mycpu()->noff != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(intr_get())
+  if (intr_get())
     panic("sched interruptible");
 
   intena = mycpu()->intena;
@@ -499,8 +829,7 @@ sched(void)
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
   struct proc *p = myproc();
   acquire(&p->lock);
@@ -511,15 +840,15 @@ yield(void)
 
 // A fork child's very first scheduling by scheduler()
 // will swtch to forkret.
-void
-forkret(void)
+void forkret(void)
 {
   static int first = 1;
 
   // Still holding p->lock from scheduler.
   release(&myproc()->lock);
 
-  if (first) {
+  if (first)
+  {
     // File system initialization must be run in the context of a
     // regular process (e.g., because it calls sleep), and thus cannot
     // be run from main().
@@ -530,13 +859,61 @@ forkret(void)
   usertrapret();
 }
 
+// Function: 6 -> Copied from copyout()
+// Copy from kernel to user.
+// Copy len bytes from src to virtual address dstva in a given page table.
+// Return 0 on success, -1 on error.
+int release_user_lock(pagetable_t pagetable, uint64 dstva)
+{
+  uint64 va0, pa0;
+
+  va0 = PGROUNDDOWN(dstva);       // floor
+  pa0 = walkaddr(pagetable, va0); // got the physical page
+  if (pa0 == 0)
+    return -1;
+
+  __sync_synchronize();
+  __sync_lock_release((uint8 *)(pa0 + (dstva - va0)));
+
+  return 0;
+}
+
+// Function: 5 -> Copied from sleep()
+// Atomically release lock and sleep on chan.
+void thread_sleep(void *chan, uint8 *lk)
+{
+  struct proc *p = myproc();
+
+  // Must acquire p->lock in order to
+  // change p->state and then call sched.
+  // Once we hold p->lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup locks p->lock),
+  // so it's okay to release lk.
+
+  acquire(&p->lock); // DOC: sleeplock1
+  release_user_lock(p->pagetable, (uint64)lk);
+
+  // Go to sleep.
+  p->chan = (void *)walkaddr(p->pagetable, (uint64)chan); // got the physical page;
+  p->state = SLEEPING;
+
+  sched();
+
+  // Tidy up.
+  p->chan = 0;
+
+  // Reacquire original lock.
+  release(&p->lock);
+  // acquire(lk); // Acquiring in user space is easier
+}
+
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
+
   // Must acquire p->lock in order to
   // change p->state and then call sched.
   // Once we hold p->lock, we can be
@@ -544,7 +921,7 @@ sleep(void *chan, struct spinlock *lk)
   // (wakeup locks p->lock),
   // so it's okay to release lk.
 
-  acquire(&p->lock);  //DOC: sleeplock1
+  acquire(&p->lock); // DOC: sleeplock1
   release(lk);
 
   // Go to sleep.
@@ -561,17 +938,43 @@ sleep(void *chan, struct spinlock *lk)
   acquire(lk);
 }
 
+// Function: 7 -> Copied from wakeup()
+// Wake up all processes sleeping on chan.
+// Must be called without any p->lock.
+void thread_wakeup(void *chan)
+{
+  struct proc *p;
+
+  chan = (void *)walkaddr(myproc()->pagetable, (uint64)chan);
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    if (p != myproc())
+    {
+      acquire(&p->lock);
+      if (p->state == SLEEPING && p->chan == chan)
+      {
+        p->state = RUNNABLE;
+        release(&p->lock);
+        break;
+      }
+      release(&p->lock);
+    }
+  }
+}
+
 // Wake up all processes sleeping on chan.
 // Must be called without any p->lock.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
   struct proc *p;
 
-  for(p = proc; p < &proc[NPROC]; p++) {
-    if(p != myproc()){
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    if (p != myproc())
+    {
       acquire(&p->lock);
-      if(p->state == SLEEPING && p->chan == chan) {
+      if (p->state == SLEEPING && p->chan == chan)
+      {
         p->state = RUNNABLE;
       }
       release(&p->lock);
@@ -582,16 +985,18 @@ wakeup(void *chan)
 // Kill the process with the given pid.
 // The victim won't exit until it tries to return
 // to user space (see usertrap() in trap.c).
-int
-kill(int pid)
+int kill(int pid)
 {
   struct proc *p;
 
-  for(p = proc; p < &proc[NPROC]; p++){
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
     acquire(&p->lock);
-    if(p->pid == pid){
+    if (p->pid == pid)
+    {
       p->killed = 1;
-      if(p->state == SLEEPING){
+      if (p->state == SLEEPING)
+      {
         // Wake process from sleep().
         p->state = RUNNABLE;
       }
@@ -603,19 +1008,17 @@ kill(int pid)
   return -1;
 }
 
-void
-setkilled(struct proc *p)
+void setkilled(struct proc *p)
 {
   acquire(&p->lock);
   p->killed = 1;
   release(&p->lock);
 }
 
-int
-killed(struct proc *p)
+int killed(struct proc *p)
 {
   int k;
-  
+
   acquire(&p->lock);
   k = p->killed;
   release(&p->lock);
@@ -625,13 +1028,15 @@ killed(struct proc *p)
 // Copy to either a user address, or kernel address,
 // depending on usr_dst.
 // Returns 0 on success, -1 on error.
-int
-either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
+int either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
 {
   struct proc *p = myproc();
-  if(user_dst){
+  if (user_dst)
+  {
     return copyout(p->pagetable, dst, src, len);
-  } else {
+  }
+  else
+  {
     memmove((char *)dst, src, len);
     return 0;
   }
@@ -640,14 +1045,16 @@ either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
 // Copy from either a user address, or kernel address,
 // depending on usr_src.
 // Returns 0 on success, -1 on error.
-int
-either_copyin(void *dst, int user_src, uint64 src, uint64 len)
+int either_copyin(void *dst, int user_src, uint64 src, uint64 len)
 {
   struct proc *p = myproc();
-  if(user_src){
+  if (user_src)
+  {
     return copyin(p->pagetable, dst, src, len);
-  } else {
-    memmove(dst, (char*)src, len);
+  }
+  else
+  {
+    memmove(dst, (char *)src, len);
     return 0;
   }
 }
@@ -655,29 +1062,28 @@ either_copyin(void *dst, int user_src, uint64 src, uint64 len)
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
+void procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [USED]      "used",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
+      [UNUSED] "unused",
+      [USED] "used",
+      [SLEEPING] "sleep ",
+      [RUNNABLE] "runble",
+      [RUNNING] "run   ",
+      [ZOMBIE] "zombie"};
   struct proc *p;
   char *state;
 
   printf("\n");
-  for(p = proc; p < &proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
     printf("%d %s %s", p->pid, state, p->name);
     printf("\n");
   }
-}
+}
\ No newline at end of file
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..183764c 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -1,5 +1,6 @@
 // Saved registers for kernel context switches.
-struct context {
+struct context
+{
   uint64 ra;
   uint64 sp;
 
@@ -19,11 +20,12 @@ struct context {
 };
 
 // Per-CPU state.
-struct cpu {
-  struct proc *proc;          // The process running on this cpu, or null.
-  struct context context;     // swtch() here to enter scheduler().
-  int noff;                   // Depth of push_off() nesting.
-  int intena;                 // Were interrupts enabled before push_off()?
+struct cpu
+{
+  struct proc *proc;      // The process running on this cpu, or null.
+  struct context context; // swtch() here to enter scheduler().
+  int noff;               // Depth of push_off() nesting.
+  int intena;             // Were interrupts enabled before push_off()?
 };
 
 extern struct cpu cpus[NCPU];
@@ -40,7 +42,8 @@ extern struct cpu cpus[NCPU];
 // the trapframe includes callee-saved user registers like s0-s11 because the
 // return-to-user path via usertrapret() doesn't return through
 // the entire kernel call stack.
-struct trapframe {
+struct trapframe
+{
   /*   0 */ uint64 kernel_satp;   // kernel page table
   /*   8 */ uint64 kernel_sp;     // top of process's kernel stack
   /*  16 */ uint64 kernel_trap;   // usertrap()
@@ -79,24 +82,33 @@ struct trapframe {
   /* 280 */ uint64 t6;
 };
 
-enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+enum procstate
+{
+  UNUSED,
+  USED,
+  SLEEPING,
+  RUNNABLE,
+  RUNNING,
+  ZOMBIE
+};
 
 // Per-process state
-struct proc {
+struct proc
+{
   struct spinlock lock;
 
   // p->lock must be held when using these:
-  enum procstate state;        // Process state
-  void *chan;                  // If non-zero, sleeping on chan
-  int killed;                  // If non-zero, have been killed
-  int xstate;                  // Exit status to be returned to parent's wait
-  int pid;                     // Process ID
+  enum procstate state; // Process state
+  void *chan;           // If non-zero, sleeping on chan
+  int killed;           // If non-zero, have been killed
+  int xstate;           // Exit status to be returned to parent's wait
+  int pid;              // Process ID
 
   // wait_lock must be held when using this:
-  struct proc *parent;         // Parent process
+  struct proc *parent; // Parent process
 
   // these are private to the process, so p->lock need not be held.
-  uint64 kstack;               // Virtual address of kernel stack
+  uint64 kstack;               // Virtual address of kernel stack. Points to the virtual memory where the stack is located
   uint64 sz;                   // Size of process memory (bytes)
   pagetable_t pagetable;       // User page table
   struct trapframe *trapframe; // data page for trampoline.S
@@ -104,4 +116,10 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  /**
+   * @author Mahir Labib Dihan
+   */
+  struct spinlock *memlock; // find places to set and release the locks // need to initialize
+  int is_thread;            // if it is thread
+  int mem_id;               // All threads will have the same physical pages with the mother, hence the same memory ID
 };
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..42f7cfb 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,31 +101,48 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
-
+/**
+ * @author Mahir Labib Dihan
+ */
+extern uint64 sys_thread_create(void);
+extern uint64 sys_thread_join(void);
+extern uint64 sys_thread_exit(void);
+extern uint64 sys_yield(void);
+extern uint64 sys_thread_sleep(void);
+extern uint64 sys_thread_wakeup(void);
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
 static uint64 (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+    [SYS_fork] sys_fork,
+    [SYS_exit] sys_exit,
+    [SYS_wait] sys_wait,
+    [SYS_pipe] sys_pipe,
+    [SYS_read] sys_read,
+    [SYS_kill] sys_kill,
+    [SYS_exec] sys_exec,
+    [SYS_fstat] sys_fstat,
+    [SYS_chdir] sys_chdir,
+    [SYS_dup] sys_dup,
+    [SYS_getpid] sys_getpid,
+    [SYS_sbrk] sys_sbrk,
+    [SYS_sleep] sys_sleep,
+    [SYS_uptime] sys_uptime,
+    [SYS_open] sys_open,
+    [SYS_write] sys_write,
+    [SYS_mknod] sys_mknod,
+    [SYS_unlink] sys_unlink,
+    [SYS_link] sys_link,
+    [SYS_mkdir] sys_mkdir,
+    [SYS_close] sys_close,
+    /**
+     * @author Mahir Labib Dihan
+     */
+    [SYS_thread_create] sys_thread_create,
+    [SYS_thread_join] sys_thread_join,
+    [SYS_thread_exit] sys_thread_exit,
+    [SYS_yield] sys_yield,
+    [SYS_thread_sleep] sys_thread_sleep,
+    [SYS_thread_wakeup] sys_thread_wakeup,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..4dc1fcc 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,12 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+/**
+ * @author Mahir Labib Dihan
+ */
+#define SYS_thread_create 22
+#define SYS_thread_join 23
+#define SYS_thread_exit 24
+#define SYS_yield 25
+#define SYS_thread_sleep 26
+#define SYS_thread_wakeup 27
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 1de184e..ca28de4 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -12,7 +12,7 @@ sys_exit(void)
   int n;
   argint(0, &n);
   exit(n);
-  return 0;  // not reached
+  return 0; // not reached
 }
 
 uint64
@@ -43,7 +43,7 @@ sys_sbrk(void)
 
   argint(0, &n);
   addr = myproc()->sz;
-  if(growproc(n) < 0)
+  if (growproc(n) < 0)
     return -1;
   return addr;
 }
@@ -57,8 +57,10 @@ sys_sleep(void)
   argint(0, &n);
   acquire(&tickslock);
   ticks0 = ticks;
-  while(ticks - ticks0 < n){
-    if(killed(myproc())){
+  while (ticks - ticks0 < n)
+  {
+    if (killed(myproc()))
+    {
       release(&tickslock);
       return -1;
     }
@@ -89,3 +91,48 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+/**
+ * @author Mahir Labib Dihan
+ */
+uint64 sys_thread_create(void)
+{
+  uint64 fcn, arg, stack;
+  argaddr(0, &fcn);
+  argaddr(1, &arg);
+  argaddr(2, &stack);
+  return thread_create(fcn, arg, stack);
+}
+uint64 sys_thread_join(void)
+{
+  int id;
+  argint(0, &id);
+  return thread_join(id);
+}
+uint64 sys_thread_exit(void)
+{
+  thread_exit();
+  return 0; // not reached
+}
+uint64 sys_yield(void)
+{
+  yield();
+  return 0; // not reached
+}
+
+uint64 sys_thread_sleep(void)
+{
+  uint64 chan, locked;
+  argaddr(0, &chan);
+  argaddr(1, &locked);
+  thread_sleep((void *)chan, (uint8 *)locked);
+  return 0;
+}
+
+uint64 sys_thread_wakeup(void)
+{
+  uint64 chan;
+  argaddr(0, &chan);
+  thread_wakeup((void *)chan);
+  return 0;
+}
\ No newline at end of file
diff --git a/kernel/vm.c b/kernel/vm.c
index 9f69783..3a31fc1 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -11,7 +11,7 @@
  */
 pagetable_t kernel_pagetable;
 
-extern char etext[];  // kernel.ld sets this to end of kernel code.
+extern char etext[]; // kernel.ld sets this to end of kernel code.
 
 extern char trampoline[]; // trampoline.S
 
@@ -21,7 +21,7 @@ kvmmake(void)
 {
   pagetable_t kpgtbl;
 
-  kpgtbl = (pagetable_t) kalloc();
+  kpgtbl = (pagetable_t)kalloc();
   memset(kpgtbl, 0, PGSIZE);
 
   // uart registers
@@ -34,10 +34,10 @@ kvmmake(void)
   kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
 
   // map kernel text executable and read-only.
-  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
+  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);
 
   // map kernel data and the physical RAM we'll make use of.
-  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
+  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);
 
   // map the trampoline for trap entry/exit to
   // the highest virtual address in the kernel.
@@ -45,21 +45,19 @@ kvmmake(void)
 
   // allocate and map a kernel stack for each process.
   proc_mapstacks(kpgtbl);
-  
+
   return kpgtbl;
 }
 
 // Initialize the one kernel_pagetable
-void
-kvminit(void)
+void kvminit(void)
 {
   kernel_pagetable = kvmmake();
 }
 
 // Switch h/w page table register to the kernel's page table,
 // and enable paging.
-void
-kvminithart()
+void kvminithart()
 {
   // wait for any previous writes to the page table memory to finish.
   sfence_vma();
@@ -85,15 +83,19 @@ kvminithart()
 pte_t *
 walk(pagetable_t pagetable, uint64 va, int alloc)
 {
-  if(va >= MAXVA)
+  if (va >= MAXVA)
     panic("walk");
 
-  for(int level = 2; level > 0; level--) {
+  for (int level = 2; level > 0; level--)
+  {
     pte_t *pte = &pagetable[PX(level, va)];
-    if(*pte & PTE_V) {
+    if (*pte & PTE_V)
+    {
       pagetable = (pagetable_t)PTE2PA(*pte);
-    } else {
-      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
+    }
+    else
+    {
+      if (!alloc || (pagetable = (pde_t *)kalloc()) == 0)
         return 0;
       memset(pagetable, 0, PGSIZE);
       *pte = PA2PTE(pagetable) | PTE_V;
@@ -111,15 +113,15 @@ walkaddr(pagetable_t pagetable, uint64 va)
   pte_t *pte;
   uint64 pa;
 
-  if(va >= MAXVA)
+  if (va >= MAXVA)
     return 0;
 
   pte = walk(pagetable, va, 0);
-  if(pte == 0)
+  if (pte == 0)
     return 0;
-  if((*pte & PTE_V) == 0)
+  if ((*pte & PTE_V) == 0)
     return 0;
-  if((*pte & PTE_U) == 0)
+  if ((*pte & PTE_U) == 0)
     return 0;
   pa = PTE2PA(*pte);
   return pa;
@@ -128,10 +130,9 @@ walkaddr(pagetable_t pagetable, uint64 va)
 // add a mapping to the kernel page table.
 // only used when booting.
 // does not flush TLB or enable paging.
-void
-kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
+void kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
 {
-  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
+  if (mappages(kpgtbl, va, sz, pa, perm) != 0)
     panic("kvmmap");
 }
 
@@ -139,24 +140,24 @@ kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
 // physical addresses starting at pa. va and size might not
 // be page-aligned. Returns 0 on success, -1 if walk() couldn't
 // allocate a needed page-table page.
-int
-mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
+int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
 {
   uint64 a, last;
   pte_t *pte;
 
-  if(size == 0)
+  if (size == 0)
     panic("mappages: size");
-  
+
   a = PGROUNDDOWN(va);
   last = PGROUNDDOWN(va + size - 1);
-  for(;;){
-    if((pte = walk(pagetable, a, 1)) == 0)
+  for (;;)
+  {
+    if ((pte = walk(pagetable, a, 1)) == 0)
       return -1;
-    if(*pte & PTE_V)
+    if (*pte & PTE_V)
       panic("mappages: remap");
     *pte = PA2PTE(pa) | perm | PTE_V;
-    if(a == last)
+    if (a == last)
       break;
     a += PGSIZE;
     pa += PGSIZE;
@@ -167,25 +168,26 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
 // Remove npages of mappings starting from va. va must be
 // page-aligned. The mappings must exist.
 // Optionally free the physical memory.
-void
-uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
+void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
 {
   uint64 a;
   pte_t *pte;
 
-  if((va % PGSIZE) != 0)
+  if ((va % PGSIZE) != 0)
     panic("uvmunmap: not aligned");
 
-  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
-    if((pte = walk(pagetable, a, 0)) == 0)
+  for (a = va; a < va + npages * PGSIZE; a += PGSIZE)
+  {
+    if ((pte = walk(pagetable, a, 0)) == 0)
       panic("uvmunmap: walk");
-    if((*pte & PTE_V) == 0)
+    if ((*pte & PTE_V) == 0)
       panic("uvmunmap: not mapped");
-    if(PTE_FLAGS(*pte) == PTE_V)
+    if (PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
-    if(do_free){
+    if (do_free)
+    {
       uint64 pa = PTE2PA(*pte);
-      kfree((void*)pa);
+      kfree((void *)pa);
     }
     *pte = 0;
   }
@@ -197,8 +199,8 @@ pagetable_t
 uvmcreate()
 {
   pagetable_t pagetable;
-  pagetable = (pagetable_t) kalloc();
-  if(pagetable == 0)
+  pagetable = (pagetable_t)kalloc();
+  if (pagetable == 0)
     return 0;
   memset(pagetable, 0, PGSIZE);
   return pagetable;
@@ -207,16 +209,15 @@ uvmcreate()
 // Load the user initcode into address 0 of pagetable,
 // for the very first process.
 // sz must be less than a page.
-void
-uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
+void uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
 {
   char *mem;
 
-  if(sz >= PGSIZE)
+  if (sz >= PGSIZE)
     panic("uvmfirst: more than a page");
   mem = kalloc();
   memset(mem, 0, PGSIZE);
-  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
+  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W | PTE_R | PTE_X | PTE_U);
   memmove(mem, src, sz);
 }
 
@@ -228,18 +229,23 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
   char *mem;
   uint64 a;
 
-  if(newsz < oldsz)
+  if (newsz < oldsz)
     return oldsz;
 
   oldsz = PGROUNDUP(oldsz);
-  for(a = oldsz; a < newsz; a += PGSIZE){
+  for (a = oldsz; a < newsz; a += PGSIZE)
+  {
     mem = kalloc();
-    if(mem == 0){
+    if (mem == 0)
+    {
       uvmdealloc(pagetable, a, oldsz);
       return 0;
     }
     memset(mem, 0, PGSIZE);
-    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
+
+    // mappages should be called for every page table with same mem_id
+    if (mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R | PTE_U | xperm) != 0)
+    {
       kfree(mem);
       uvmdealloc(pagetable, a, oldsz);
       return 0;
@@ -255,11 +261,14 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
 uint64
 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 {
-  if(newsz >= oldsz)
+  if (newsz >= oldsz)
     return oldsz;
 
-  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
+  if (PGROUNDUP(newsz) < PGROUNDUP(oldsz))
+  {
     int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
+
+    // unmap from all pagetables
     uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
   }
 
@@ -268,79 +277,127 @@ uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 
 // Recursively free page-table pages.
 // All leaf mappings must already have been removed.
-void
-freewalk(pagetable_t pagetable)
+void freewalk(pagetable_t pagetable)
 {
   // there are 2^9 = 512 PTEs in a page table.
-  for(int i = 0; i < 512; i++){
+  for (int i = 0; i < 512; i++)
+  {
     pte_t pte = pagetable[i];
-    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
+    if ((pte & PTE_V) && (pte & (PTE_R | PTE_W | PTE_X)) == 0)
+    {
       // this PTE points to a lower-level page table.
       uint64 child = PTE2PA(pte);
       freewalk((pagetable_t)child);
       pagetable[i] = 0;
-    } else if(pte & PTE_V){
+    }
+    else if (pte & PTE_V)
+    {
       panic("freewalk: leaf");
     }
   }
-  kfree((void*)pagetable);
+  kfree((void *)pagetable);
+}
+
+// Function: 2 -> Copied from uvmfree()
+void uvmfreethread(pagetable_t pagetable, uint64 sz)
+{
+  if (sz > 0)
+    uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 0); // Don't free physical memory
+  freewalk(pagetable);
 }
 
 // Free user memory pages,
 // then free page-table pages.
-void
-uvmfree(pagetable_t pagetable, uint64 sz)
+void uvmfree(pagetable_t pagetable, uint64 sz)
 {
-  if(sz > 0)
-    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
+  if (sz > 0)
+    uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1);
   freewalk(pagetable);
 }
 
+// Function: 1 -> Copied from uvmcopy()
+int uvmmirror(pagetable_t src, pagetable_t dst, uint64 src_sz, uint64 dst_sz)
+{
+  pte_t *pte;
+  uint64 pa, va;
+  uint flags;
+
+  if (dst_sz < src_sz) // allocate
+  {
+    dst_sz = PGROUNDUP(dst_sz);
+    for (va = dst_sz; va < src_sz; va += PGSIZE)
+    {
+      if ((pte = walk(src, va, 0)) == 0)
+      {
+        panic("uvmmirror: pte should exist");
+      }
+      if ((*pte & PTE_V) == 0)
+      {
+        panic("uvmmirror: page not present");
+      }
+      pa = PTE2PA(*pte);
+      flags = PTE_FLAGS(*pte);
+      if (mappages(dst, va, PGSIZE, pa, flags) != 0)
+      {
+        uvmdealloc(dst, va, dst_sz);
+        return -1;
+      }
+    }
+  }
+  else if (PGROUNDUP(dst_sz) > PGROUNDUP(src_sz)) // deallocate
+  {
+    int npages = (PGROUNDUP(dst_sz) - PGROUNDUP(src_sz)) / PGSIZE;
+    // unmap from all pagetables
+    uvmunmap(dst, PGROUNDUP(src_sz), npages, 0);
+  }
+  return 0;
+}
+
 // Given a parent process's page table, copy
 // its memory into a child's page table.
 // Copies both the page table and the
 // physical memory.
 // returns 0 on success, -1 on failure.
 // frees any allocated pages on failure.
-int
-uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
+int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 {
   pte_t *pte;
   uint64 pa, i;
   uint flags;
   char *mem;
 
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walk(old, i, 0)) == 0)
+  for (i = 0; i < sz; i += PGSIZE)
+  {
+    if ((pte = walk(old, i, 0)) == 0)
       panic("uvmcopy: pte should exist");
-    if((*pte & PTE_V) == 0)
+    if ((*pte & PTE_V) == 0)
       panic("uvmcopy: page not present");
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
+    if ((mem = kalloc()) == 0)
       goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
+    memmove(mem, (char *)pa, PGSIZE);
+    if (mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)
+    {
       kfree(mem);
       goto err;
     }
   }
   return 0;
 
- err:
+err:
   uvmunmap(new, 0, i / PGSIZE, 1);
   return -1;
 }
 
 // mark a PTE invalid for user access.
 // used by exec for the user stack guard page.
-void
-uvmclear(pagetable_t pagetable, uint64 va)
+void uvmclear(pagetable_t pagetable, uint64 va)
 {
   pte_t *pte;
-  
+
   pte = walk(pagetable, va, 0);
-  if(pte == 0)
+  if (pte == 0)
     panic("uvmclear");
   *pte &= ~PTE_U;
 }
@@ -348,18 +405,18 @@ uvmclear(pagetable_t pagetable, uint64 va)
 // Copy from kernel to user.
 // Copy len bytes from src to virtual address dstva in a given page table.
 // Return 0 on success, -1 on error.
-int
-copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
+int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 {
   uint64 n, va0, pa0;
 
-  while(len > 0){
+  while (len > 0)
+  {
     va0 = PGROUNDDOWN(dstva);
     pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
+    if (pa0 == 0)
       return -1;
     n = PGSIZE - (dstva - va0);
-    if(n > len)
+    if (n > len)
       n = len;
     memmove((void *)(pa0 + (dstva - va0)), src, n);
 
@@ -373,18 +430,18 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 // Copy from user to kernel.
 // Copy len bytes to dst from virtual address srcva in a given page table.
 // Return 0 on success, -1 on error.
-int
-copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
+int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 {
   uint64 n, va0, pa0;
 
-  while(len > 0){
+  while (len > 0)
+  {
     va0 = PGROUNDDOWN(srcva);
     pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
+    if (pa0 == 0)
       return -1;
     n = PGSIZE - (srcva - va0);
-    if(n > len)
+    if (n > len)
       n = len;
     memmove(dst, (void *)(pa0 + (srcva - va0)), n);
 
@@ -399,28 +456,32 @@ copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 // Copy bytes to dst from virtual address srcva in a given page table,
 // until a '\0', or max.
 // Return 0 on success, -1 on error.
-int
-copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
+int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
 {
   uint64 n, va0, pa0;
   int got_null = 0;
 
-  while(got_null == 0 && max > 0){
+  while (got_null == 0 && max > 0)
+  {
     va0 = PGROUNDDOWN(srcva);
     pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
+    if (pa0 == 0)
       return -1;
     n = PGSIZE - (srcva - va0);
-    if(n > max)
+    if (n > max)
       n = max;
 
-    char *p = (char *) (pa0 + (srcva - va0));
-    while(n > 0){
-      if(*p == '\0'){
+    char *p = (char *)(pa0 + (srcva - va0));
+    while (n > 0)
+    {
+      if (*p == '\0')
+      {
         *dst = '\0';
         got_null = 1;
         break;
-      } else {
+      }
+      else
+      {
         *dst = *p;
       }
       --n;
@@ -431,9 +492,12 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
 
     srcva = va0 + PGSIZE;
   }
-  if(got_null){
+  if (got_null)
+  {
     return 0;
-  } else {
+  }
+  else
+  {
     return -1;
   }
 }
diff --git a/user/condvar.h b/user/condvar.h
new file mode 100644
index 0000000..ea25fac
--- /dev/null
+++ b/user/condvar.h
@@ -0,0 +1,36 @@
+#ifndef __CONDITIONAL_VARIABLE_H
+#define __CONDITIONAL_VARIABLE_H
+#include "kernel/types.h"
+#include "user/user.h"
+#include "user/mutex.h"
+// https://www.andrew.cmu.edu/course/15-440-sp11/applications/ln/lecture7.html
+// Conditional Variable
+struct thread_cond
+{
+    int signal;
+};
+
+void thread_cond_init(struct thread_cond *cv)
+{
+    // noting to init
+    // we just need an address to wait on
+}
+
+/**
+ * The call pthread_cond_wait performs three actions:
+ * 1. unlock the mutex
+ * 2. waits (sleeps until pthread_cond_signal is called on the same condition variable). It does 1 and 2 atomically.
+ * 3. Before returning, locks the mutex
+ */
+void thread_cond_wait(struct thread_cond *cv, struct thread_mutex *mutex)
+{
+    thread_sleep(&cv->signal, &mutex->locked); // Atomic mutex unlock and thread sleep
+    thread_mutex_lock(mutex);
+}
+
+// Only wakeup one thread
+void thread_cond_signal(struct thread_cond *cv)
+{
+    thread_wakeup(&cv->signal);
+}
+#endif
\ No newline at end of file
diff --git a/user/mutex.h b/user/mutex.h
new file mode 100644
index 0000000..5a9e08b
--- /dev/null
+++ b/user/mutex.h
@@ -0,0 +1,24 @@
+#ifndef __MUTEX_H
+#define __MUTEX_H
+#include "kernel/types.h"
+// Mutex Lock
+struct thread_mutex
+{
+    uint8 locked;
+};
+void thread_mutex_init(struct thread_mutex *m)
+{
+    m->locked = 0;
+}
+void thread_mutex_lock(struct thread_mutex *m)
+{
+    while (__sync_lock_test_and_set(&m->locked, 1) != 0)
+        yield();
+    __sync_synchronize();
+}
+void thread_mutex_unlock(struct thread_mutex *m)
+{
+    __sync_synchronize();
+    __sync_lock_release(&m->locked);
+}
+#endif
\ No newline at end of file
diff --git a/user/producer_consumer.c b/user/producer_consumer.c
new file mode 100644
index 0000000..ffe6fc5
--- /dev/null
+++ b/user/producer_consumer.c
@@ -0,0 +1,97 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "user/semaphore.h"
+#include "user/queue.h"
+
+struct queue q;
+// a mutex object lock
+struct thread_mutex mutex;
+// a semaphore object empty
+struct thread_sem empty;
+// a semaphore object full
+struct thread_sem full;
+
+struct thread_mutex printlock;
+void init_semaphore()
+{
+    initq(&q);
+    // initialize mutex lock
+    thread_mutex_init(&mutex);
+    thread_mutex_init(&printlock);
+    // initialize semaphore empty with 5
+    thread_sem_init(&empty, 5);
+    // initialize semaphore full with 0
+    thread_sem_init(&full, 0);
+}
+void ProducerFunc(void *arg)
+{
+    thread_mutex_lock(&printlock);
+    printf("%s\n", (char *)arg);
+    thread_mutex_unlock(&printlock);
+    int i;
+    for (i = 1; i <= 10; i++)
+    {
+        // wait for semphore empty
+        thread_sem_wait(&empty);
+        // wait for mutex lock
+        thread_mutex_lock(&mutex);
+        sleep(1);
+        enqueue(&q, i);
+
+        thread_mutex_lock(&printlock);
+        printf("producer produced item %d\n", i);
+        thread_mutex_unlock(&printlock);
+
+        // unlock mutex lock
+        thread_mutex_unlock(&mutex);
+        // post semaphore full
+        thread_sem_post(&full);
+    }
+    thread_exit();
+    return;
+}
+
+void ConsumerFunc(void *arg)
+{
+    thread_mutex_lock(&printlock);
+    printf("%s\n", (char *)arg);
+    thread_mutex_unlock(&printlock);
+    int i;
+    for (i = 1; i <= 10; i++)
+    {
+        // wait for semphore full
+        thread_sem_wait(&full);
+        // wait for mutex lock
+        thread_mutex_lock(&mutex);
+        sleep(1);
+        int item = dequeue(&q);
+        thread_mutex_lock(&printlock);
+        printf("consumer consumed item %d\n", item);
+        thread_mutex_unlock(&printlock);
+
+        // unlock mutex lock
+        thread_mutex_unlock(&mutex);
+        // post semaphore empty
+        thread_sem_post(&empty);
+    }
+    thread_exit();
+    return;
+}
+int main(void)
+{
+    init_semaphore();
+    char *message1 = "i am producer";
+    char *message2 = "i am consumer";
+    void *s1, *s2;
+    int thread1, thread2, r1, r2;
+    s1 = malloc(4096);
+    s2 = malloc(4096);
+    thread1 = thread_create(ProducerFunc, (void *)message1, s1);
+    thread2 = thread_create(ConsumerFunc, (void *)message2, s2);
+    r1 = thread_join(thread1);
+    r2 = thread_join(thread2);
+    printf("Threads finished: (%d):%d, (%d):%d\n",
+           thread1, r1, thread2, r2);
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/queue.h b/user/queue.h
new file mode 100644
index 0000000..c8851ee
--- /dev/null
+++ b/user/queue.h
@@ -0,0 +1,34 @@
+#ifndef __QUEUE_H
+#define __QUEUE_H
+struct queue
+{
+    int arr[16];
+    int front;
+    int rear;
+    int size;
+};
+
+void initq(struct queue *q)
+{
+    q->front = 0;
+    q->rear = 0;
+    q->size = 0;
+}
+void enqueue(struct queue *q, int x)
+{
+    q->arr[q->rear] = x;
+    q->rear = (q->rear + 1) % 16;
+    q->size++;
+}
+int dequeue(struct queue *q)
+{
+    if (q->size > 0)
+    {
+        int tmp = q->arr[q->front];
+        q->front = (q->front + 1) % 16;
+        q->size--;
+        return tmp;
+    }
+    return -1;
+}
+#endif // __QUEUE_H
\ No newline at end of file
diff --git a/user/semaphore.h b/user/semaphore.h
new file mode 100644
index 0000000..ac4238f
--- /dev/null
+++ b/user/semaphore.h
@@ -0,0 +1,40 @@
+#include "user/condvar.h"
+
+#ifndef __SEMAPHORE_H
+#define __SEMAPHORE_H
+// Semaphore
+struct thread_sem
+{
+    int count;
+    struct thread_mutex m;
+    struct thread_cond cv;
+};
+
+void thread_sem_init(struct thread_sem *s, int value)
+{
+    s->count = value;
+    thread_mutex_init(&s->m);
+    thread_cond_init(&s->cv);
+}
+void thread_sem_post(struct thread_sem *s)
+{
+    thread_mutex_lock(&s->m);
+
+    s->count++;
+    /* Did we increment from zero to one - time to signal a thread sleeping inside thread_sem_post */
+    if (s->count == 1) /* Wake up one waiting thread! */
+        thread_cond_signal(&s->cv);
+    thread_mutex_unlock(&s->m);
+}
+void thread_sem_wait(struct thread_sem *s)
+{
+    thread_mutex_lock(&s->m);
+    while (s->count == 0) // Spurious Wakeup?
+    {
+        thread_cond_wait(&s->cv, &s->m);
+    }
+    s->count--;
+    thread_mutex_unlock(&s->m);
+}
+
+#endif // __SEMAPHORE_H
\ No newline at end of file
diff --git a/user/spinlock.h b/user/spinlock.h
new file mode 100644
index 0000000..783b25c
--- /dev/null
+++ b/user/spinlock.h
@@ -0,0 +1,26 @@
+#include "kernel/types.h"
+
+#ifndef __SPIN_LOCK_H
+#define __SPIN_LOCK_H
+struct thread_spinlock
+{
+    uint8 locked;
+};
+
+void thread_spin_init(struct thread_spinlock *lk)
+{
+    lk->locked = 0;
+}
+void thread_spin_lock(struct thread_spinlock *lk)
+{
+    while (__sync_lock_test_and_set(&lk->locked, 1) != 0)
+        ;
+
+    __sync_synchronize();
+}
+void thread_spin_unlock(struct thread_spinlock *lk)
+{
+    __sync_synchronize();
+    __sync_lock_release(&lk->locked);
+}
+#endif // __SPIN_LOCK_H
\ No newline at end of file
diff --git a/user/thread.c b/user/thread.c
new file mode 100644
index 0000000..6e62d29
--- /dev/null
+++ b/user/thread.c
@@ -0,0 +1,104 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "user/mutex.h"
+
+#include "user/spinlock.h"
+
+struct balance
+{
+    char name[32];
+    int amount;
+};
+
+volatile int total_balance = 0;
+volatile unsigned int delay(unsigned int d)
+{
+    unsigned int i;
+    for (i = 0; i < d; i++)
+    {
+        __asm volatile("nop" ::
+                           :);
+    }
+    return i;
+}
+
+struct thread_spinlock lock;
+struct thread_mutex mlock;
+struct thread_mutex printlock;
+// void f(void *arg)
+// {
+//     while (total_balance < 8500)
+//     {
+//     }
+
+//     thread_mutex_lock(&printlock);
+//     printf("Child Thread Started\n");
+//     thread_mutex_unlock(&printlock);
+//     delay(100000);
+//     thread_mutex_lock(&printlock);
+//     printf("Child Thread Ended\n");
+//     thread_mutex_unlock(&printlock);
+
+//     thread_exit();
+// }
+void do_work(void *arg)
+{
+    int i;
+    int old;
+    // void *s1;
+    // s1 = malloc(5 * 4096);
+    // thread_create(f, 0, s1); // child thread of a thread
+    struct balance *b = (struct balance *)arg;
+
+    thread_mutex_lock(&printlock);
+    printf("Starting do_work: s:%s\n", b->name);
+    thread_mutex_unlock(&printlock);
+
+    for (i = 0; i < b->amount; i++)
+    {
+        // lock and mlock will be implemented by you.
+        // thread_spin_lock(&lock);
+        thread_mutex_lock(&mlock);
+        old = total_balance;
+        delay(100000);
+        total_balance = old + 1;
+        if (old + 1 != total_balance)
+            printf("we missed an update. old: %d total_balance: % d\n ", old, total_balance);
+        thread_mutex_unlock(&mlock);
+        // thread_spin_unlock(&lock);
+    }
+
+    thread_mutex_lock(&printlock);
+    printf("Done s:%s\n", b->name);
+    thread_mutex_unlock(&printlock);
+
+    thread_exit();
+    return;
+}
+int main(int argc, char *argv[])
+{
+    thread_spin_init(&lock);
+    thread_mutex_init(&mlock);
+    thread_mutex_init(&printlock);
+    struct balance b1 = {"b1", 3200};
+    struct balance b2 = {"b2", 2800};
+
+    void *s1, *s2;
+    int thread1, thread2, r1, r2;
+    s1 = malloc(4096); // 4096 is the PGSIZE defined in kernel/riscv.h
+    s2 = malloc(4096);
+
+    thread1 = thread_create(do_work, (void *)&b1, s1);
+    thread2 = thread_create(do_work, (void *)&b2, s2);
+
+    r1 = thread_join(thread1);
+    r2 = thread_join(thread2);
+
+    thread_mutex_lock(&printlock);
+    printf("Threads finished: (%d):%d, (%d):%d, shared balance:%d\n",
+           thread1, r1, thread2, r2, total_balance);
+    thread_mutex_unlock(&printlock);
+
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 4d398d5..899ceaf 100644
--- a/user/user.h
+++ b/user/user.h
@@ -3,39 +3,48 @@ struct stat;
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
-int wait(int*);
-int pipe(int*);
-int write(int, const void*, int);
-int read(int, void*, int);
+int wait(int *);
+int pipe(int *);
+int write(int, const void *, int);
+int read(int, void *, int);
 int close(int);
 int kill(int);
-int exec(const char*, char**);
-int open(const char*, int);
-int mknod(const char*, short, short);
-int unlink(const char*);
-int fstat(int fd, struct stat*);
-int link(const char*, const char*);
-int mkdir(const char*);
-int chdir(const char*);
+int exec(const char *, char **);
+int open(const char *, int);
+int mknod(const char *, short, short);
+int unlink(const char *);
+int fstat(int fd, struct stat *);
+int link(const char *, const char *);
+int mkdir(const char *);
+int chdir(const char *);
 int dup(int);
 int getpid(void);
-char* sbrk(int);
+char *sbrk(int);
 int sleep(int);
 int uptime(void);
+/**
+ * @author Mahir Labib Dihan
+ */
+int thread_create(void (*fcn)(void *), void *arg, void *stack);
+int thread_join(int thread_id);
+void thread_exit(void);
+void yield(void);
+void thread_sleep(void *, uint8 *);
+void thread_wakeup(void *);
 
 // ulib.c
-int stat(const char*, struct stat*);
-char* strcpy(char*, const char*);
-void *memmove(void*, const void*, int);
-char* strchr(const char*, char c);
-int strcmp(const char*, const char*);
-void fprintf(int, const char*, ...);
-void printf(const char*, ...);
-char* gets(char*, int max);
-uint strlen(const char*);
-void* memset(void*, int, uint);
-void* malloc(uint);
-void free(void*);
-int atoi(const char*);
+int stat(const char *, struct stat *);
+char *strcpy(char *, const char *);
+void *memmove(void *, const void *, int);
+char *strchr(const char *, char c);
+int strcmp(const char *, const char *);
+void fprintf(int, const char *, ...);
+void printf(const char *, ...);
+char *gets(char *, int max);
+uint strlen(const char *);
+void *memset(void *, int, uint);
+void *malloc(uint);
+void free(void *);
+int atoi(const char *);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..e3aeeae 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,9 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("thread_create");
+entry("thread_join");
+entry("thread_exit");
+entry("yield");
+entry("thread_sleep");
+entry("thread_wakeup");
\ No newline at end of file
