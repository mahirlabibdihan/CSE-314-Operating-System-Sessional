diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..281d1d8
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "defs.h": "c"
+    }
+}
diff --git a/Makefile b/Makefile
index 39a99d7..765d58b 100644
--- a/Makefile
+++ b/Makefile
@@ -24,6 +24,7 @@ OBJS = \
   $K/sleeplock.o \
   $K/file.o \
   $K/pipe.o \
+  $K/swap.o \
   $K/exec.o \
   $K/sysfile.o \
   $K/kernelvec.o \
@@ -132,6 +133,11 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_test1\
+	$U/_test2\
+	$U/_test3\
+	$U/_test4\
+	$U/_pageinfo\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
@@ -153,7 +159,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 3
+CPUS := 1
 endif
 
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..f5b57d2 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -8,6 +8,8 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct swap;
+struct livepage;
 
 // bio.c
 void            binit(void);
@@ -36,6 +38,8 @@ int             filewrite(struct file*, uint64, int n);
 
 // fs.c
 void            fsinit(int);
+uint balloc(uint dev);
+void bfree(int dev, uint b);
 int             dirlink(struct inode*, char*, uint);
 struct inode*   dirlookup(struct inode*, char*, uint*);
 struct inode*   ialloc(uint, short);
@@ -107,6 +111,18 @@ int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
 
+void livepageinfo(void);
+int getPidFromPT(pagetable_t);
+void startlog(void);
+void stoplog(void);
+
+// swap.c
+void swapinit(void);
+void swapfree(struct swap *);
+struct swap *swapalloc(void);
+void swapout(struct swap *dst_sp, char *src_pa);
+void swapin(char *dst_pa, struct swap *src_sp);
+
 // swtch.S
 void            swtch(struct context*, struct context*);
 
@@ -174,6 +190,16 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 
+// Dihan
+void insertlivepage(pagetable_t, uint64, uint64);
+void removelivepage(pagetable_t, uint64);
+void removelivepage_bypagetable(pagetable_t);
+void removelivepage_bypa(uint64);
+void increaserefcount(struct swap *);
+int livepagecount(pagetable_t);
+void pagetablecount(pagetable_t, uint64);
+void pageinit(void);
+
 // plic.c
 void            plicinit(void);
 void            plicinithart(void);
diff --git a/kernel/fs.c b/kernel/fs.c
index c6bab15..d2c8cf7 100644
--- a/kernel/fs.c
+++ b/kernel/fs.c
@@ -62,8 +62,7 @@ bzero(int dev, int bno)
 
 // Allocate a zeroed disk block.
 // returns 0 if out of disk space.
-static uint
-balloc(uint dev)
+uint balloc(uint dev)
 {
   int b, bi, m;
   struct buf *bp;
@@ -88,8 +87,7 @@ balloc(uint dev)
 }
 
 // Free a disk block.
-static void
-bfree(int dev, uint b)
+void bfree(int dev, uint b)
 {
   struct buf *bp;
   int bi, m;
@@ -97,6 +95,7 @@ bfree(int dev, uint b)
   bp = bread(dev, BBLOCK(b, sb));
   bi = b % BPB;
   m = 1 << (bi % 8);
+
   if((bp->data[bi/8] & m) == 0)
     panic("freeing free block");
   bp->data[bi/8] &= ~m;
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 0699e7e..7834e0e 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -23,6 +23,7 @@ struct {
   struct run *freelist;
 } kmem;
 
+// extern struct spinlock lplock;
 void
 kinit()
 {
@@ -60,6 +61,8 @@ kfree(void *pa)
   r->next = kmem.freelist;
   kmem.freelist = r;
   release(&kmem.lock);
+
+  removelivepage_bypa((uint64)pa);
 }
 
 // Allocate one 4096-byte page of physical memory.
diff --git a/kernel/main.c b/kernel/main.c
index f0d3171..a9bee08 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -17,7 +17,9 @@ main()
     printf("xv6 kernel is booting\n");
     printf("\n");
     kinit();         // physical page allocator
+    swapinit();
     kvminit();       // create kernel page table
+    pageinit();
     kvminithart();   // turn on paging
     procinit();      // process table
     trapinit();      // trap vectors
diff --git a/kernel/proc.c b/kernel/proc.c
index 959b778..6dea69a 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -159,7 +159,12 @@ freeproc(struct proc *p)
     kfree((void*)p->trapframe);
   p->trapframe = 0;
   if(p->pagetable)
+  {
+    // release(&p->lock);
     proc_freepagetable(p->pagetable, p->sz);
+    // acquire(&p->lock);
+  }
+
   p->pagetable = 0;
   p->sz = 0;
   p->pid = 0;
@@ -197,7 +202,11 @@ proc_pagetable(struct proc *p)
   // trampoline.S.
   if(mappages(pagetable, TRAPFRAME, PGSIZE,
               (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
+    // release(&p->lock);
+
     uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+    // acquire(&p->lock);
+
     uvmfree(pagetable, 0);
     return 0;
   }
@@ -210,6 +219,7 @@ proc_pagetable(struct proc *p)
 void
 proc_freepagetable(pagetable_t pagetable, uint64 sz)
 {
+
   uvmunmap(pagetable, TRAMPOLINE, 1, 0);
   uvmunmap(pagetable, TRAPFRAME, 1, 0);
   uvmfree(pagetable, sz);
@@ -288,12 +298,14 @@ fork(void)
     return -1;
   }
 
+  release(&np->lock);
   // Copy user memory from parent to child.
   if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
     freeproc(np);
     release(&np->lock);
     return -1;
   }
+  acquire(&np->lock);
   np->sz = p->sz;
 
   // copy saved user registers.
@@ -414,9 +426,11 @@ wait(uint64 addr)
             release(&wait_lock);
             return -1;
           }
-          freeproc(pp);
+
           release(&pp->lock);
           release(&wait_lock);
+          freeproc(pp);
+
           return pid;
         }
         release(&pp->lock);
@@ -487,7 +501,10 @@ sched(void)
   if(!holding(&p->lock))
     panic("sched p->lock");
   if(mycpu()->noff != 1)
+  {
     panic("sched locks");
+  }
+
   if(p->state == RUNNING)
     panic("sched running");
   if(intr_get())
@@ -681,3 +698,52 @@ procdump(void)
     printf("\n");
   }
 }
+
+void livepageinfo(void)
+{
+  struct proc *p;
+  printf("\n=============== Live page stats ===============\n");
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    int n_livepages = livepagecount(p->pagetable);
+    if (n_livepages)
+    {
+      acquire(&p->lock);
+      printf("PID: %d,\tName: %s,\tLive: %d pages\n", p->pid, p->name, n_livepages);
+      release(&p->lock);
+    }
+  }
+  printf("================================================\n\n");
+
+  printf("\n=============== Page table stats ===============\n");
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    acquire(&p->lock);
+    pagetablecount(p->pagetable, p->sz);
+    release(&p->lock);
+  }
+  printf("================================================\n\n");
+}
+
+int getPidFromPT(pagetable_t pagetable)
+{
+  struct proc *p;
+  for (p = proc; p < &proc[NPROC]; p++)
+  {
+    if (p->pagetable == pagetable)
+    {
+      return p->pid;
+    }
+  }
+  return -1;
+}
+
+extern int vmlog;
+void startlog()
+{
+  vmlog = 1;
+}
+void stoplog()
+{
+  vmlog = 0;
+}
\ No newline at end of file
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..e6b006b 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -344,6 +344,11 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
 
+// Dihan: PTEs in riscv have 10 flags of which 8 are used by hardware
+// A present bit indicates whether this page is in physical memory or on disk (i.e., it has been swapped out).
+#define PTE_S (1L << 8) // You need to keep track of if a page is present in physical memory.
+// Change it to PTE_P -> Present Bit. It's not Present Bit now.
+
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
 
diff --git a/kernel/swap.c b/kernel/swap.c
new file mode 100644
index 0000000..a3386c1
--- /dev/null
+++ b/kernel/swap.c
@@ -0,0 +1,163 @@
+#include "types.h"
+#include "riscv.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "defs.h"
+#include "param.h"
+#include "sleeplock.h"
+#include "buf.h"
+
+#define NBLOCKPERPAGE (PGSIZE / BSIZE)
+
+struct swap
+{
+  uint blocknos[NBLOCKPERPAGE];
+  int ref_count; // Dihan
+};
+
+struct run
+{
+  struct run *next;
+};
+
+struct
+{
+  struct spinlock lock;
+  struct run *freelist;
+} swapmem;
+
+// Initialize swapmem
+void swapinit(void)
+{
+  initlock(&swapmem.lock, "swapmem");
+  swapmem.freelist = 0;
+}
+
+// Allocate one swap struct.
+// Returns a pointer to the swap struct.
+// Returns 0 if the memory cannot be allocated.
+struct swap *
+swapalloc(void)
+{
+  struct run *r;
+  struct swap *s;
+
+  acquire(&swapmem.lock);
+  r = swapmem.freelist;
+  if (!r)
+  {
+    release(&swapmem.lock);
+    char *mem = kalloc();
+    char *mem_end = mem + PGSIZE;
+    for (; mem + sizeof(struct swap) <= mem_end; mem += sizeof(struct swap))
+    {
+      r = (struct run *)mem;
+
+      acquire(&swapmem.lock);
+      r->next = swapmem.freelist;
+      swapmem.freelist = r;
+      release(&swapmem.lock);
+    }
+    acquire(&swapmem.lock);
+    r = swapmem.freelist;
+  }
+  swapmem.freelist = r->next;
+  release(&swapmem.lock);
+
+  s = (struct swap *)r;
+  if (s)
+  {
+    memset((char *)s->blocknos, 0, sizeof(s->blocknos)); // fill with zeros
+    s->ref_count = 1;                                    // Dihan
+  }
+
+  return s;
+}
+
+extern int vmlog;
+// Free the swap struct pointed by s, and the blocks
+// contained in s, which normally should have been returned
+// by a call to swapalloc() and swapout().
+void swapfree(struct swap *s)
+{
+  uint *blockno;
+  struct run *r;
+
+  if (!s)
+    panic("swapfree");
+
+  // Dihan
+  s->ref_count--;
+  if (s->ref_count > 0)
+  {
+    if (vmlog)
+      printf("Couldn't free swap struct because of %d more references\n", s->ref_count);
+    return;
+  }
+
+  begin_op();
+  for (blockno = s->blocknos; blockno < &s->blocknos[NBLOCKPERPAGE]; blockno++)
+  {
+    if (*blockno)
+    {
+      bfree(ROOTDEV, *blockno);
+    }
+  }
+
+  end_op();
+  r = (struct run *)s;
+
+  acquire(&swapmem.lock);
+  r->next = swapmem.freelist;
+  swapmem.freelist = r;
+  release(&swapmem.lock);
+}
+
+// Swap out a given physical page src_pa to disk.
+// The metadata for retriving src_pa will be saved
+// to dst_pa which normally should have been returned
+// by a call to swapalloc().
+void swapout(struct swap *dst_sp, char *src_pa)
+{
+  // printf("Swapping Out => PA: %p\n", src_pa);
+  uint *blockno;
+  struct buf *bp;
+
+  begin_op();
+  for (blockno = dst_sp->blocknos; blockno < &dst_sp->blocknos[NBLOCKPERPAGE]; blockno++, src_pa += BSIZE)
+  {
+    *blockno = balloc(ROOTDEV);
+    if (*blockno == 0)
+      panic("swapout");
+    bp = bread(ROOTDEV, *blockno);
+    memmove(bp->data, src_pa, BSIZE);
+    log_write(bp);
+    brelse(bp);
+  }
+  end_op();
+}
+
+// Swap in a page into dst_pa from disk using src_sp.
+// src_sp should normally be updated with metadata
+// for retriving the page by a call to swapout().
+void swapin(char *dst_pa, struct swap *src_sp)
+{
+  uint *blockno;
+  struct buf *bp;
+
+  if (!dst_pa)
+    panic("swapin");
+  for (blockno = src_sp->blocknos; blockno < &src_sp->blocknos[NBLOCKPERPAGE]; blockno++, dst_pa += BSIZE)
+  {
+    bp = bread(ROOTDEV, *blockno);
+    memmove(dst_pa, bp->data, BSIZE);
+    brelse(bp);
+  }
+  // printf("Swapping In => PA: %p\n", dst_pa);
+}
+
+// Dihan
+void increaserefcount(struct swap *s)
+{
+  s->ref_count++;
+}
\ No newline at end of file
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..cd9d65e 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -102,30 +102,37 @@ extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
 
+extern uint64 sys_livepageinfo(void);
+extern uint64 sys_startlog(void);
+extern uint64 sys_stoplog(void);
+
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
 static uint64 (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+    [SYS_fork] sys_fork,
+    [SYS_exit] sys_exit,
+    [SYS_wait] sys_wait,
+    [SYS_pipe] sys_pipe,
+    [SYS_read] sys_read,
+    [SYS_kill] sys_kill,
+    [SYS_exec] sys_exec,
+    [SYS_fstat] sys_fstat,
+    [SYS_chdir] sys_chdir,
+    [SYS_dup] sys_dup,
+    [SYS_getpid] sys_getpid,
+    [SYS_sbrk] sys_sbrk,
+    [SYS_sleep] sys_sleep,
+    [SYS_uptime] sys_uptime,
+    [SYS_open] sys_open,
+    [SYS_write] sys_write,
+    [SYS_mknod] sys_mknod,
+    [SYS_unlink] sys_unlink,
+    [SYS_link] sys_link,
+    [SYS_mkdir] sys_mkdir,
+    [SYS_close] sys_close,
+    [SYS_livepageinfo] sys_livepageinfo,
+    [SYS_startlog] sys_startlog,
+    [SYS_stoplog] sys_stoplog,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..b4b7969 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+
+#define SYS_livepageinfo 22
+#define SYS_startlog 23
+#define SYS_stoplog 24
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 1de184e..b4835a5 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -89,3 +89,19 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64 sys_livepageinfo(void)
+{
+  livepageinfo();
+  return 0;
+}
+uint64 sys_startlog(void)
+{
+  startlog();
+  return 0;
+}
+uint64 sys_stoplog(void)
+{
+  stoplog();
+  return 0;
+}
\ No newline at end of file
diff --git a/kernel/trap.c b/kernel/trap.c
index 512c850..0622b12 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -14,6 +14,7 @@ extern char trampoline[], uservec[], userret[];
 // in kernelvec.S, calls kerneltrap().
 void kernelvec();
 
+extern int vmlog;
 extern int devintr();
 
 void
@@ -65,14 +66,66 @@ usertrap(void)
     intr_on();
 
     syscall();
-  } else if((which_dev = devintr()) != 0){
+  }
+
+  // Now, xv6 should panic when a swapped out page is accessed. This panic is generated due to a usertrap that corresponds to page fault.
+  // 12 - Instruction page fault
+  // 13 - Load page fault
+  // 15 - Store/AMO page fault
+  else if (r_scause() == 12 || r_scause() == 13 || r_scause() == 15)
+  {
+    pte_t *pte;
+
+    char *mem;
+
+    uint64 va = r_stval(); // virtual address that faulted
+    va = PGROUNDDOWN(va);
+    pte = walk(p->pagetable, va, 0);
+
+    if (pte == 0 || va >= MAXVA || va % PGSIZE != 0 || (*pte & PTE_U) == 0 || (*pte & PTE_S) == 0)
+    {
+      p->killed = 1;
+      goto err;
+    }
+
+    if ((*pte & PTE_S) != 0)
+    {
+      // swap in page
+      struct swap *src_swap = (struct swap *)((uint64)*pte >> 10);
+
+      uint flags;
+      flags = PTE_FLAGS(*pte);
+      flags &= ~PTE_S;
+      flags |= PTE_V | PTE_R | PTE_W | PTE_U;
+
+      if ((mem = kalloc()) == 0)
+        goto err;
+
+      if (vmlog)
+        printf("(Kernel) Swap in(Fault) => PID: %d PT: %p VA: %p PA: %p\n", p->pid, p->pagetable, va, mem);
+      swapin(mem, src_swap);
+      *pte = PA2PTE(mem) | flags;
+
+      if (vmlog)
+        printf("(Kernel) Swap free => PID: %d PT: %p VA: %p PA: %p\n", p->pid, p->pagetable, va, mem);
+
+      swapfree(src_swap);
+
+      insertlivepage(p->pagetable, (uint64)va, (uint64)mem);
+    }
+  }
+  else if ((which_dev = devintr()) != 0)
+  {
     // ok
-  } else {
+  }
+  else
+  {
     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
     printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
     setkilled(p);
   }
 
+err:
   if(killed(p))
     exit(-1);
 
diff --git a/kernel/vm.c b/kernel/vm.c
index 9f69783..f25067d 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -5,13 +5,106 @@
 #include "riscv.h"
 #include "defs.h"
 #include "fs.h"
+#include "spinlock.h"
+
+int vmlog = 0;
+// Dihan
+#define MAXPHYPAGES 50
+// struct spinlock lplock;
+struct livepage
+{
+  int pid;
+  pagetable_t pagetable;
+  uint64 va;
+  uint64 pa;
+  struct livepage *next;
+};
+
+struct freepage
+{
+  struct freepage *next;
+};
+
+struct datastructure
+{
+  struct spinlock lock;
+  struct freepage *freelist;
+  struct livepage *live_head, *live_tail;
+  int n_livepages;
+};
+
+struct datastructure ds;
+// struct livepage livepages[MAXPHYPAGES];
+// int n_livepages = 0;
+
+void pageinit(void)
+{
+  initlock(&ds.lock, "info_pages_free");
+  ds.freelist = 0;
+  ds.live_head = 0;
+  ds.live_tail = 0;
+}
+
+struct livepage *
+list_alloc(void)
+{
+  struct freepage *r;
+  struct livepage *p;
+
+  acquire(&ds.lock);
+  r = ds.freelist;
+  if (!r)
+  {
+    release(&ds.lock);
+    char *mem = kalloc();
+    char *mem_end = mem + PGSIZE;
+    for (; mem + sizeof(struct livepage) <= mem_end; mem += sizeof(struct livepage))
+    {
+      r = (struct freepage *)mem;
+
+      acquire(&ds.lock);
+      r->next = ds.freelist;
+      ds.freelist = r;
+      release(&ds.lock);
+    }
+    acquire(&ds.lock);
+    r = ds.freelist;
+  }
+  ds.n_livepages++;
+  ds.freelist = r->next;
+  release(&ds.lock);
+
+  p = (struct livepage *)r;
+  p->pagetable = 0;
+  p->next = 0;
+  p->pa = 0;
+  p->va = 0;
+
+  return p;
+}
+
+void list_dealloc(struct livepage *p)
+{
+  struct freepage *r;
+  if (!p)
+  {
+    panic("dealloc\n");
+  }
+  r = (struct freepage *)p;
+
+  acquire(&ds.lock);
+  r->next = ds.freelist;
+  ds.freelist = r;
+  ds.n_livepages--;
+  release(&ds.lock);
+}
 
 /*
  * the kernel's page table.
  */
 pagetable_t kernel_pagetable;
 
-extern char etext[];  // kernel.ld sets this to end of kernel code.
+extern char etext[]; // kernel.ld sets this to end of kernel code.
 
 extern char trampoline[]; // trampoline.S
 
@@ -21,7 +114,7 @@ kvmmake(void)
 {
   pagetable_t kpgtbl;
 
-  kpgtbl = (pagetable_t) kalloc();
+  kpgtbl = (pagetable_t)kalloc();
   memset(kpgtbl, 0, PGSIZE);
 
   // uart registers
@@ -34,10 +127,10 @@ kvmmake(void)
   kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
 
   // map kernel text executable and read-only.
-  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
+  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);
 
   // map kernel data and the physical RAM we'll make use of.
-  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
+  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);
 
   // map the trampoline for trap entry/exit to
   // the highest virtual address in the kernel.
@@ -45,21 +138,19 @@ kvmmake(void)
 
   // allocate and map a kernel stack for each process.
   proc_mapstacks(kpgtbl);
-  
+
   return kpgtbl;
 }
 
 // Initialize the one kernel_pagetable
-void
-kvminit(void)
+void kvminit(void)
 {
   kernel_pagetable = kvmmake();
 }
 
 // Switch h/w page table register to the kernel's page table,
 // and enable paging.
-void
-kvminithart()
+void kvminithart()
 {
   // wait for any previous writes to the page table memory to finish.
   sfence_vma();
@@ -85,15 +176,19 @@ kvminithart()
 pte_t *
 walk(pagetable_t pagetable, uint64 va, int alloc)
 {
-  if(va >= MAXVA)
+  if (va >= MAXVA)
     panic("walk");
 
-  for(int level = 2; level > 0; level--) {
+  for (int level = 2; level > 0; level--)
+  {
     pte_t *pte = &pagetable[PX(level, va)];
-    if(*pte & PTE_V) {
+    if (*pte & PTE_V)
+    {
       pagetable = (pagetable_t)PTE2PA(*pte);
-    } else {
-      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
+    }
+    else
+    {
+      if (!alloc || (pagetable = (pde_t *)kalloc()) == 0)
         return 0;
       memset(pagetable, 0, PGSIZE);
       *pte = PA2PTE(pagetable) | PTE_V;
@@ -111,16 +206,47 @@ walkaddr(pagetable_t pagetable, uint64 va)
   pte_t *pte;
   uint64 pa;
 
-  if(va >= MAXVA)
+  if (va >= MAXVA)
     return 0;
 
   pte = walk(pagetable, va, 0);
-  if(pte == 0)
+
+  if (pte == 0)
+  {
     return 0;
-  if((*pte & PTE_V) == 0)
+  }
+
+  // May be we have swapped out the page and reset the valid bit.
+  if ((*pte & PTE_V) == 0 && (*pte & PTE_S) == 0)
     return 0;
-  if((*pte & PTE_U) == 0)
+  if ((*pte & PTE_U) == 0)
     return 0;
+
+  // First try to swapin
+  if ((*pte & PTE_S) != 0)
+  {
+    struct swap *src_swap = (struct swap *)((uint64)*pte >> 10);
+    char *mem;
+    uint64 flags = PTE_FLAGS(*pte);
+    flags &= ~PTE_S;
+    flags |= PTE_V;
+    if ((mem = kalloc()) == 0)
+    {
+      panic("walkaddress: kalloc\n");
+    }
+
+    if (vmlog)
+      printf("(Kernel) Swap in => PID: %d PT: %p VA: %p PA: %p\n", getPidFromPT(pagetable), pagetable, va, mem);
+    swapin(mem, src_swap);
+
+    *pte = PA2PTE(mem) | flags;
+
+    if (vmlog)
+      printf("(Kernel) Swap free => PID: %d PT: %p VA: %p PA: %p\n", getPidFromPT(pagetable), pagetable, va, mem);
+    swapfree(src_swap);
+
+    insertlivepage(pagetable, va, (uint64)mem);
+  }
   pa = PTE2PA(*pte);
   return pa;
 }
@@ -128,10 +254,9 @@ walkaddr(pagetable_t pagetable, uint64 va)
 // add a mapping to the kernel page table.
 // only used when booting.
 // does not flush TLB or enable paging.
-void
-kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
+void kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
 {
-  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
+  if (mappages(kpgtbl, va, sz, pa, perm) != 0)
     panic("kvmmap");
 }
 
@@ -139,24 +264,24 @@ kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
 // physical addresses starting at pa. va and size might not
 // be page-aligned. Returns 0 on success, -1 if walk() couldn't
 // allocate a needed page-table page.
-int
-mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
+int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
 {
   uint64 a, last;
   pte_t *pte;
 
-  if(size == 0)
+  if (size == 0)
     panic("mappages: size");
-  
+
   a = PGROUNDDOWN(va);
   last = PGROUNDDOWN(va + size - 1);
-  for(;;){
-    if((pte = walk(pagetable, a, 1)) == 0)
+  for (;;)
+  {
+    if ((pte = walk(pagetable, a, 1)) == 0)
       return -1;
-    if(*pte & PTE_V)
+    if (*pte & PTE_V)
       panic("mappages: remap");
     *pte = PA2PTE(pa) | perm | PTE_V;
-    if(a == last)
+    if (a == last)
       break;
     a += PGSIZE;
     pa += PGSIZE;
@@ -167,26 +292,58 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
 // Remove npages of mappings starting from va. va must be
 // page-aligned. The mappings must exist.
 // Optionally free the physical memory.
-void
-uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
+void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
 {
+  // printf("Hi there\n");
   uint64 a;
   pte_t *pte;
 
-  if((va % PGSIZE) != 0)
+  if ((va % PGSIZE) != 0)
     panic("uvmunmap: not aligned");
 
-  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
-    if((pte = walk(pagetable, a, 0)) == 0)
+  for (a = va; a < va + npages * PGSIZE; a += PGSIZE)
+  {
+    if ((pte = walk(pagetable, a, 0)) == 0)
       panic("uvmunmap: walk");
-    if((*pte & PTE_V) == 0)
+
+    if ((*pte & PTE_V) == 0 && (*pte & PTE_S) == 0)
       panic("uvmunmap: not mapped");
-    if(PTE_FLAGS(*pte) == PTE_V)
+    if (PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
-    if(do_free){
+
+    if (*pte & PTE_S)
+    {
+      // First swap in. Then remove the entry from pagetable and livepages.
+      struct swap *src_swap = (struct swap *)((uint64)*pte >> 10);
+      char *mem;
+      uint64 flags = PTE_FLAGS(*pte);
+      flags &= ~PTE_S;
+      flags |= PTE_V;
+      if ((mem = kalloc()) == 0)
+      {
+        panic("uvmunmap: kalloc\n");
+      }
+
+      swapin(mem, src_swap);
+
+      if (vmlog)
+        printf("(Kernel) Swap in => PID: %d PT: %p VA: %p PA: %p\n", getPidFromPT(pagetable), pagetable, a, mem);
+
+      *pte = PA2PTE(mem) | flags;
+
+      if (vmlog)
+        printf("(Kernel) Swap free => PID: %d PT: %p VA: %p PA: %p\n", getPidFromPT(pagetable), pagetable, a, mem);
+      swapfree(src_swap);
+
+      insertlivepage(pagetable, a, (uint64)mem);
+    }
+
+    if (do_free)
+    {
       uint64 pa = PTE2PA(*pte);
-      kfree((void*)pa);
+      kfree((void *)pa);
     }
+    removelivepage(pagetable, a);
     *pte = 0;
   }
 }
@@ -197,8 +354,8 @@ pagetable_t
 uvmcreate()
 {
   pagetable_t pagetable;
-  pagetable = (pagetable_t) kalloc();
-  if(pagetable == 0)
+  pagetable = (pagetable_t)kalloc();
+  if (pagetable == 0)
     return 0;
   memset(pagetable, 0, PGSIZE);
   return pagetable;
@@ -207,16 +364,15 @@ uvmcreate()
 // Load the user initcode into address 0 of pagetable,
 // for the very first process.
 // sz must be less than a page.
-void
-uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
+void uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
 {
   char *mem;
 
-  if(sz >= PGSIZE)
+  if (sz >= PGSIZE)
     panic("uvmfirst: more than a page");
   mem = kalloc();
   memset(mem, 0, PGSIZE);
-  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
+  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W | PTE_R | PTE_X | PTE_U);
   memmove(mem, src, sz);
 }
 
@@ -228,22 +384,34 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
   char *mem;
   uint64 a;
 
-  if(newsz < oldsz)
+  if (newsz < oldsz)
     return oldsz;
 
   oldsz = PGROUNDUP(oldsz);
-  for(a = oldsz; a < newsz; a += PGSIZE){
+  for (a = oldsz; a < newsz; a += PGSIZE)
+  {
     mem = kalloc();
-    if(mem == 0){
+    if (mem == 0)
+    {
       uvmdealloc(pagetable, a, oldsz);
       return 0;
     }
     memset(mem, 0, PGSIZE);
-    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
+    if (mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R | PTE_U | xperm) != 0)
+    {
       kfree(mem);
       uvmdealloc(pagetable, a, oldsz);
       return 0;
     }
+
+    // if ((xperm & PTE_X))
+    // {
+    //   printf("Not Executable\n");
+    // }
+    // if ((xperm & PTE_X) == 0) // Not executable
+    {
+      insertlivepage(pagetable, a, (uint64)mem);
+    }
   }
   return newsz;
 }
@@ -255,10 +423,11 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
 uint64
 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 {
-  if(newsz >= oldsz)
+  if (newsz >= oldsz)
     return oldsz;
 
-  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
+  if (PGROUNDUP(newsz) < PGROUNDUP(oldsz))
+  {
     int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
     uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
   }
@@ -268,31 +437,35 @@ uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 
 // Recursively free page-table pages.
 // All leaf mappings must already have been removed.
-void
-freewalk(pagetable_t pagetable)
+void freewalk(pagetable_t pagetable)
 {
   // there are 2^9 = 512 PTEs in a page table.
-  for(int i = 0; i < 512; i++){
+  for (int i = 0; i < 512; i++)
+  {
     pte_t pte = pagetable[i];
-    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
+    if ((pte & PTE_V) && (pte & (PTE_R | PTE_W | PTE_X)) == 0)
+    {
       // this PTE points to a lower-level page table.
       uint64 child = PTE2PA(pte);
       freewalk((pagetable_t)child);
+      removelivepage_bypagetable(pagetable);
       pagetable[i] = 0;
-    } else if(pte & PTE_V){
+    }
+    else if (pte & PTE_V)
+    {
       panic("freewalk: leaf");
     }
   }
-  kfree((void*)pagetable);
+  kfree((void *)pagetable);
 }
 
 // Free user memory pages,
 // then free page-table pages.
-void
-uvmfree(pagetable_t pagetable, uint64 sz)
+void uvmfree(pagetable_t pagetable, uint64 sz)
 {
-  if(sz > 0)
-    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
+  if (sz > 0)
+    uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1);
+
   freewalk(pagetable);
 }
 
@@ -302,45 +475,70 @@ uvmfree(pagetable_t pagetable, uint64 sz)
 // physical memory.
 // returns 0 on success, -1 on failure.
 // frees any allocated pages on failure.
-int
-uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
+int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 {
   pte_t *pte;
   uint64 pa, i;
   uint flags;
   char *mem;
 
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walk(old, i, 0)) == 0)
+  for (i = 0; i < sz; i += PGSIZE)
+  {
+    if ((pte = walk(old, i, 0)) == 0)
       panic("uvmcopy: pte should exist");
-    if((*pte & PTE_V) == 0)
+    if ((*pte & PTE_V) == 0 && (*pte & PTE_S) == 0)
       panic("uvmcopy: page not present");
-    pa = PTE2PA(*pte);
-    flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
-      goto err;
+
+    // In disk
+    if ((*pte & PTE_S) != 0)
+    {
+      // swap in the page
+      struct swap *src_swap = (struct swap *)((uint64)*pte >> 10);
+      increaserefcount(src_swap);
+      // Copies the swap struct if it's swapped out
+      pte_t *pte_new = walk(new, i, 0);
+      *pte_new = *pte; // Directly copy the pte. No need to copy physical memory.
+      if (vmlog)
+        printf("(Kernel) PID: %d => Copying struct swap* since the parent page is swapped out. VA: %p\n", getPidFromPT(new), i);
+    }
+    else
+    {
+      pa = PTE2PA(*pte);
+      flags = PTE_FLAGS(*pte);
+      if ((mem = kalloc()) == 0)
+        goto err;
+      memmove(mem, (char *)pa, PGSIZE);
+      if (mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)
+      {
+        kfree(mem);
+        goto err;
+      }
+      // if ((flags & PTE_X))
+      // {
+      //   printf("Not Executable\n");
+      // }
+      // if ((flags & PTE_X) == 0)
+      {
+        insertlivepage(new, i, (uint64)mem);
+      }
     }
   }
   return 0;
 
- err:
+err:
+
   uvmunmap(new, 0, i / PGSIZE, 1);
   return -1;
 }
 
 // mark a PTE invalid for user access.
 // used by exec for the user stack guard page.
-void
-uvmclear(pagetable_t pagetable, uint64 va)
+void uvmclear(pagetable_t pagetable, uint64 va)
 {
   pte_t *pte;
-  
+
   pte = walk(pagetable, va, 0);
-  if(pte == 0)
+  if (pte == 0)
     panic("uvmclear");
   *pte &= ~PTE_U;
 }
@@ -348,18 +546,18 @@ uvmclear(pagetable_t pagetable, uint64 va)
 // Copy from kernel to user.
 // Copy len bytes from src to virtual address dstva in a given page table.
 // Return 0 on success, -1 on error.
-int
-copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
+int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 {
   uint64 n, va0, pa0;
 
-  while(len > 0){
+  while (len > 0)
+  {
     va0 = PGROUNDDOWN(dstva);
     pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
+    if (pa0 == 0)
       return -1;
     n = PGSIZE - (dstva - va0);
-    if(n > len)
+    if (n > len)
       n = len;
     memmove((void *)(pa0 + (dstva - va0)), src, n);
 
@@ -373,18 +571,18 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 // Copy from user to kernel.
 // Copy len bytes to dst from virtual address srcva in a given page table.
 // Return 0 on success, -1 on error.
-int
-copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
+int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 {
   uint64 n, va0, pa0;
 
-  while(len > 0){
+  while (len > 0)
+  {
     va0 = PGROUNDDOWN(srcva);
     pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
+    if (pa0 == 0)
       return -1;
     n = PGSIZE - (srcva - va0);
-    if(n > len)
+    if (n > len)
       n = len;
     memmove(dst, (void *)(pa0 + (srcva - va0)), n);
 
@@ -399,28 +597,32 @@ copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 // Copy bytes to dst from virtual address srcva in a given page table,
 // until a '\0', or max.
 // Return 0 on success, -1 on error.
-int
-copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
+int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
 {
   uint64 n, va0, pa0;
   int got_null = 0;
 
-  while(got_null == 0 && max > 0){
+  while (got_null == 0 && max > 0)
+  {
     va0 = PGROUNDDOWN(srcva);
     pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
+    if (pa0 == 0)
       return -1;
     n = PGSIZE - (srcva - va0);
-    if(n > max)
+    if (n > max)
       n = max;
 
-    char *p = (char *) (pa0 + (srcva - va0));
-    while(n > 0){
-      if(*p == '\0'){
+    char *p = (char *)(pa0 + (srcva - va0));
+    while (n > 0)
+    {
+      if (*p == '\0')
+      {
         *dst = '\0';
         got_null = 1;
         break;
-      } else {
+      }
+      else
+      {
         *dst = *p;
       }
       --n;
@@ -431,9 +633,224 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
 
     srcva = va0 + PGSIZE;
   }
-  if(got_null){
+  if (got_null)
+  {
     return 0;
-  } else {
+  }
+  else
+  {
     return -1;
   }
 }
+
+void insertlivepage(pagetable_t pagetable, uint64 va, uint64 pa)
+{
+  acquire(&ds.lock);
+  if (ds.n_livepages == MAXPHYPAGES)
+  {
+    // livepageinfo();
+    struct swap *dst_swap = swapalloc();
+
+    if (vmlog)
+    {
+      // livepageinfo();
+      printf("(Kernel) Swap out => PID: %d PT: %p VA: %p PA: %p\n", ds.live_head->pid != -1 ? ds.live_head->pid : getPidFromPT(ds.live_head->pagetable), ds.live_head->pagetable, ds.live_head->va, ds.live_head->pa);
+    }
+    release(&ds.lock);
+
+    swapout(dst_swap, (char *)ds.live_head->pa);
+    pte_t *pte = walk(ds.live_head->pagetable, ds.live_head->va, 0);
+    uint16 flags = PTE_FLAGS(*pte);
+
+    // Make not valid
+    flags &= ~PTE_V;
+    flags |= PTE_S;
+
+    // Remove the physical address from memory
+    kfree((void *)PGROUNDDOWN(ds.live_head->pa));
+    // Adding the swap struct pointer in pte
+    *pte = ((uint64)dst_swap << 10) | flags;
+
+    acquire(&ds.lock);
+  }
+  release(&ds.lock);
+
+  struct livepage *new_page = list_alloc();
+  new_page->va = va;
+  new_page->pa = pa;
+  new_page->pagetable = pagetable;
+  new_page->pid = getPidFromPT(pagetable);
+
+  acquire(&ds.lock);
+  if (ds.live_tail)
+  {
+    ds.live_tail->next = new_page;
+    ds.live_tail = new_page;
+  }
+  else
+  {
+    ds.live_head = ds.live_tail = new_page;
+  }
+  if (vmlog)
+    printf("(Kernel) Insert => PID: %d PT: %p  VA: %p PA: %p\n", ds.live_tail->pid != -1 ? ds.live_tail->pid : getPidFromPT(ds.live_tail->pagetable), ds.live_tail->pagetable, ds.live_tail->va, ds.live_tail->pa);
+  // printf("Added: PT: %p, %p\n", ds.live_tail->pagetable, ds.live_tail->va);
+  release(&ds.lock);
+}
+
+void removelivepage(pagetable_t pagetable, uint64 va)
+{
+  // printf("Remove live page %p\n", va);
+
+  acquire(&ds.lock);
+  struct livepage *curr = ds.live_head, *prev = 0;
+
+  while (curr)
+  {
+    if (curr->pagetable == pagetable && curr->va == va)
+    {
+      if (curr == ds.live_head)
+      {
+        ds.live_head = curr->next;
+      }
+      else
+      {
+        prev->next = curr->next;
+      }
+
+      if (curr == ds.live_tail)
+      {
+        ds.live_tail = prev;
+      }
+      if (vmlog)
+        printf("(Kernel) Remove(PT+VA) => PID: %d PT: %p VA: %p PA: %p\n", curr->pid != -1 ? curr->pid : getPidFromPT(curr->pagetable), curr->pagetable, curr->va, curr->pa);
+      release(&ds.lock);
+      list_dealloc(curr);
+      return;
+    }
+    prev = curr;
+    curr = curr->next;
+  }
+  release(&ds.lock);
+}
+
+void removelivepage_bypagetable(pagetable_t pagetable)
+{
+  // printf("Remove live page by pagetable\n");
+
+  acquire(&ds.lock);
+  struct livepage *curr = ds.live_head, *prev = 0;
+
+  while (curr)
+  {
+    if (curr->pagetable == pagetable)
+    {
+      if (curr == ds.live_head)
+      {
+        ds.live_head = curr->next;
+      }
+      else
+      {
+        prev->next = curr->next;
+      }
+
+      if (curr == ds.live_tail)
+      {
+        ds.live_tail = prev;
+      }
+      if (vmlog)
+        printf("(Kernel) Remove(PT) => PID: %d PT: %p VA: %p PA: %p\n", curr->pid != -1 ? curr->pid : getPidFromPT(curr->pagetable), curr->pagetable, curr->va, curr->pa);
+
+      release(&ds.lock);
+      list_dealloc(curr);
+      return;
+    }
+    prev = curr;
+    curr = curr->next;
+  }
+  release(&ds.lock);
+}
+
+void removelivepage_bypa(uint64 pa)
+{
+  // printf("Remove live page by physical address %p\n", pa);
+  acquire(&ds.lock);
+
+  struct livepage *curr = ds.live_head, *prev = 0;
+
+  while (curr)
+  {
+    if (curr->pa == pa)
+    {
+      if (curr == ds.live_head)
+      {
+        ds.live_head = curr->next;
+      }
+      else
+      {
+        prev->next = curr->next;
+      }
+
+      if (curr == ds.live_tail)
+      {
+        ds.live_tail = prev;
+      }
+      if (vmlog)
+        printf("(Kernel) Remove(PA) => PID: %d PT: %p VA: %p PA: %p\n", curr->pid != -1 ? curr->pid : getPidFromPT(curr->pagetable), curr->pagetable, curr->va, curr->pa);
+
+      release(&ds.lock);
+      list_dealloc(curr);
+      return;
+    }
+    // printf("Not Found Page\n");
+    prev = curr;
+    curr = curr->next;
+  }
+  release(&ds.lock);
+}
+
+int livepagecount(pagetable_t pagetable)
+{
+  int count = 0;
+
+  acquire(&ds.lock);
+  struct livepage *curr = ds.live_head;
+  while (curr)
+  {
+    if (curr->pagetable == pagetable)
+    {
+      count++;
+    }
+    curr = curr->next;
+  }
+  release(&ds.lock);
+  return count;
+}
+
+void pagetablecount(pagetable_t pagetable, uint64 sz)
+{
+  pte_t *pte;
+  uint64 i;
+  int livecount = 0, swapcount = 0;
+  acquire(&ds.lock);
+  for (i = 0; i < sz; i += PGSIZE)
+  {
+    if ((pte = walk(pagetable, i, 0)) == 0)
+      continue;
+    if ((*pte & PTE_V) == 0 && (*pte & PTE_S) == 0)
+      continue;
+
+    if (*pte & PTE_S)
+    {
+      swapcount++;
+    }
+    else if (*pte & PTE_V)
+    {
+      livecount++;
+    }
+  }
+  release(&ds.lock);
+  if (livecount + swapcount)
+  {
+    printf("PID: %d,\tLive: %d pages,\tSwapped: %d pages\n", getPidFromPT(pagetable), livecount, swapcount);
+  }
+}
\ No newline at end of file
diff --git a/user/pageinfo.c b/user/pageinfo.c
new file mode 100644
index 0000000..6dce9e9
--- /dev/null
+++ b/user/pageinfo.c
@@ -0,0 +1,14 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+#include "kernel/syscall.h"
+#include "kernel/memlayout.h"
+#include "kernel/riscv.h"
+int main()
+{
+    livepageinfo();
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/test1.c b/user/test1.c
new file mode 100644
index 0000000..dc78cd6
--- /dev/null
+++ b/user/test1.c
@@ -0,0 +1,47 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+#include "kernel/syscall.h"
+#include "kernel/memlayout.h"
+#include "kernel/riscv.h"
+
+int main(int argc, char *argv[])
+{
+    // startlog(); // Uncomment to see kernel log
+
+    printf("Process #%d started.\n", getpid());
+    livepageinfo();
+    int num_pages = 5;
+    if (argc > 1)
+    {
+        num_pages = atoi(argv[1]);
+    }
+
+    int page_size = 4096;
+    int array_size = num_pages * page_size;
+
+    printf("Process #%d: Allocating %d pages\n\n", getpid(), num_pages);
+    char *array = sbrk(array_size);
+    if (array == 0)
+    {
+        printf("Process #%d: Failed to allocate memory\n", getpid());
+        printf("Process #%d finished.\n", getpid());
+        stoplog();
+        exit(1);
+    }
+    sleep(10);
+    livepageinfo();
+
+    printf("Process #%d: Deallocating %d pages\n\n", getpid(), num_pages);
+    sbrk(-array_size);
+    sleep(10);
+    livepageinfo();
+
+    printf("Process #%d finished.\n", getpid());
+
+    stoplog();
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/test2.c b/user/test2.c
new file mode 100644
index 0000000..a5cf210
--- /dev/null
+++ b/user/test2.c
@@ -0,0 +1,50 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+#include "kernel/syscall.h"
+#include "kernel/memlayout.h"
+#include "kernel/riscv.h"
+
+int main(int argc, char *argv[])
+{
+    // startlog(); // Uncomment to see kernel log
+    printf("Process #%d started.\n", getpid());
+    livepageinfo();
+
+    char *array[50];
+    printf("Process #%d: Allocating 50 pages.\n", getpid());
+    for (int i = 0; i < 50; i++)
+    {
+        array[i] = sbrk(4096);
+        array[i][0] = i;
+    }
+    livepageinfo();
+
+    sleep(10);
+    printf("Process #%d: Writing some pages.\n", getpid());
+    for (int i = 0; i < 50; i++)
+    {
+        if (i % 7 == 0)
+        {
+            printf("Process #%d: Writing array[%d] = %d\n", getpid(), i, 2 * i);
+            array[i][0] = 2 * i;
+        }
+    }
+    livepageinfo();
+
+    sleep(10);
+    // printf("Process #%d: Printing 50 values.\n", getpid());
+    for (int i = 0; i < 50; i++)
+    {
+        printf("Process #%d: Reading array[%d]->%d\n", getpid(), i, array[i][0]);
+    }
+    printf("\n");
+    livepageinfo();
+
+    printf("Process #%d finished.\n", getpid());
+    stoplog();
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/test3.c b/user/test3.c
new file mode 100644
index 0000000..1b9f87c
--- /dev/null
+++ b/user/test3.c
@@ -0,0 +1,48 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+#include "kernel/syscall.h"
+#include "kernel/memlayout.h"
+#include "kernel/riscv.h"
+
+int main(int argc, char *argv[])
+{
+    // startlog(); // Uncomment to see kernel log
+    printf("Process #%d started.\n", getpid());
+
+    livepageinfo();
+
+    char *array[50];
+    printf("Process #%d: Allocating 50 pages.\n", getpid());
+    for (int i = 0; i < 50; i++)
+    {
+        array[i] = sbrk(4096);
+        array[i][0] = 50 - i;
+    }
+    livepageinfo();
+
+    sleep(10);
+    printf("Process #%d: Creating child process\n", getpid());
+    if (fork() == 0)
+    {
+        printf("Process #%d: Child process created\n", getpid());
+        livepageinfo();
+        printf("Process #%d: Accessing array[0]\n", getpid());
+        printf("array[%d]: %d\n", 0, array[0][0]);
+        livepageinfo();
+    }
+    else
+    {
+        wait(0);
+        // startlog(); // Uncomment to see kernel log
+        printf("Process #%d: Resuming parent process\n", getpid());
+        livepageinfo();
+    }
+
+    printf("Process #%d finished.\n", getpid());
+    stoplog();
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/test4.c b/user/test4.c
new file mode 100644
index 0000000..d132187
--- /dev/null
+++ b/user/test4.c
@@ -0,0 +1,56 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+#include "kernel/syscall.h"
+#include "kernel/memlayout.h"
+#include "kernel/riscv.h"
+
+int main(int argc, char *argv[])
+{
+    // startlog(); // Uncomment to see kernel log
+    printf("Process #%d started.\n", getpid());
+
+    livepageinfo();
+
+    printf("Process #%d: Allocating 50 pages\n", getpid());
+    char *array[50];
+    for (int i = 0; i < 50; i++)
+    {
+        array[i] = sbrk(4096);
+        array[i][0] = 50 - i;
+    }
+    livepageinfo();
+
+    sleep(10);
+    printf("Process #%d: Creating child process\n", getpid());
+    if (fork() == 0)
+    {
+        printf("Process #%d: Child process created\n", getpid());
+        sleep(1);
+        livepageinfo();
+        printf("Process #%d: Accessing array[0]\n", getpid());
+        printf("array[%d]: %d\n", 0, array[0][0]);
+        livepageinfo();
+    }
+    else
+    {
+        wait(0);
+        // startlog(); // Uncomment to see kernel log
+        printf("Process #%d: Resuming parent process\n", getpid());
+        livepageinfo();
+        printf("Process #%d: Accessing array[0]\n", getpid());
+        printf("array[%d]: %d\n", 0, array[0][0]);
+        livepageinfo();
+    }
+
+    sleep(10);
+    printf("Process #%d: Deallocating heap.\n", getpid());
+    sbrk(-4096 * 50);
+    livepageinfo();
+    printf("Process #%d finished.\n", getpid());
+    stoplog();
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 4d398d5..0e779cf 100644
--- a/user/user.h
+++ b/user/user.h
@@ -23,6 +23,11 @@ char* sbrk(int);
 int sleep(int);
 int uptime(void);
 
+// Dihan
+void livepageinfo();
+void startlog();
+void stoplog();
+
 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..8ae3506 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,7 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+
+entry("livepageinfo");
+entry("startlog");
+entry("stoplog");
\ No newline at end of file
